# Converter and Mapper Layer

This document covers the type conversion patterns used to translate between OpenAPI models and domain models.

## Overview

**Location:**
- `internal/converter/` - Goverter-generated converters
- `internal/mapper/` - EmbedMDMapper implementation

## Conversion Flow

```
OpenAPI Models (pkg/openapi/)
        │
        ▼ OpenAPI Converter
Domain Models (internal/db/models/)
        │
        ▼ Repository Mapper
Database Schema (internal/db/schema/)
```

## Goverter Code Generation

### Configuration

```go
// internal/converter/openapi_converter.go

// goverter:converter
// goverter:output:file ./generated/openapi_converter.gen.go
// goverter:wrapErrors
// goverter:enum:unknown @error
// goverter:matchIgnoreCase
// goverter:useZeroValueOnPointerInconsistency
type OpenAPIConverter interface {
    // Conversion method signatures...
}
```

### Generation Command

```bash
make gen/converter
```

### Generated Output

```go
// internal/converter/generated/openapi_converter.gen.go
// Code generated by github.com/jmattheis/goverter

package generated

type OpenAPIConverterImpl struct{}

func (c *OpenAPIConverterImpl) ConvertRegisteredModelCreate(
    source *openapi.RegisteredModelCreate,
) (*openapi.RegisteredModel, error) {
    // Generated conversion logic
}
```

## OpenAPI Converter

### Create Conversions

Ignores auto-generated fields (ID, timestamps):

```go
// goverter:converter
type OpenAPIConverter interface {
    // goverter:ignore Id CreateTimeSinceEpoch LastUpdateTimeSinceEpoch
    ConvertRegisteredModelCreate(source *openapi.RegisteredModelCreate) (*openapi.RegisteredModel, error)

    // goverter:ignore Id CreateTimeSinceEpoch LastUpdateTimeSinceEpoch
    ConvertModelVersionCreate(source *openapi.ModelVersionCreate) (*openapi.ModelVersion, error)

    // goverter:ignore Id CreateTimeSinceEpoch LastUpdateTimeSinceEpoch
    ConvertModelArtifactCreate(source *openapi.ModelArtifactCreate) (*openapi.ModelArtifact, error)
}
```

### Update Conversions

Ignores ID and read-only fields:

```go
// goverter:converter
type OpenAPIConverter interface {
    // goverter:ignore Id CreateTimeSinceEpoch
    ConvertRegisteredModelUpdate(source *openapi.RegisteredModelUpdate) (*openapi.RegisteredModel, error)

    // goverter:ignore Id CreateTimeSinceEpoch RegisteredModelId
    ConvertModelVersionUpdate(source *openapi.ModelVersionUpdate) (*openapi.ModelVersion, error)
}
```

## OpenAPIToEmbedMD Converter

Converts OpenAPI models to domain models:

```go
// goverter:converter
type OpenAPIToEmbedMDConverter interface {
    // goverter:map . Attributes
    // goverter:ignore ID TypeID Properties CustomProperties
    ToRegisteredModel(source *openapi.RegisteredModel) (*models.RegisteredModel, error)

    // goverter:map . Attributes
    // goverter:ignore ID TypeID Properties CustomProperties
    ToModelVersion(source *openapi.ModelVersion) (*models.ModelVersion, error)
}
```

## EmbedMDToOpenAPI Converter

Converts domain models back to OpenAPI:

```go
// goverter:converter
type EmbedMDToOpenAPIConverter interface {
    // goverter:map Attributes .
    // goverter:ignore CustomProperties
    FromRegisteredModel(source *models.RegisteredModel) (*openapi.RegisteredModel, error)

    // goverter:map Attributes .
    // goverter:ignore CustomProperties
    FromModelVersion(source *models.ModelVersion) (*openapi.ModelVersion, error)
}
```

## EmbedMDMapper

### Structure

```go
// internal/mapper/embedmd_mapper.go
type EmbedMDMapper struct {
    openAPIConverter      converter.OpenAPIToEmbedMDConverter
    embedMDConverter      converter.EmbedMDToOpenAPIConverter
    *generated.OpenAPIConverterImpl
    *generated.OpenAPIReconcilerImpl
    typesMap              map[string]int32
}

func NewEmbedMDMapper(typesMap map[string]int32) *EmbedMDMapper {
    return &EmbedMDMapper{
        openAPIConverter:       &generated.OpenAPIToEmbedMDConverterImpl{},
        embedMDConverter:       &generated.EmbedMDToOpenAPIConverterImpl{},
        OpenAPIConverterImpl:   &generated.OpenAPIConverterImpl{},
        OpenAPIReconcilerImpl:  &generated.OpenAPIReconcilerImpl{},
        typesMap:               typesMap,
    }
}
```

### Wrapper Pattern

```go
type OpenAPIModelWrapper[M any] struct {
    TypeId           int32
    Model            *M
    ParentResourceId *string
}
```

### MapFromRegisteredModel

```go
func (m *EmbedMDMapper) MapFromRegisteredModel(
    registeredModel *openapi.RegisteredModel,
) (*models.RegisteredModel, error) {
    // Convert OpenAPI to domain model
    entity, err := m.openAPIConverter.ToRegisteredModel(registeredModel)
    if err != nil {
        return nil, err
    }

    // Set type ID from typesMap
    typeID := m.typesMap[defaults.RegisteredModelTypeName]
    entity.TypeID = &typeID

    // Convert custom properties
    if registeredModel.CustomProperties != nil {
        props := m.convertCustomProperties(registeredModel.CustomProperties)
        entity.CustomProperties = &props
    }

    return entity, nil
}
```

### MapToRegisteredModel

```go
func (m *EmbedMDMapper) MapToRegisteredModel(
    entity *models.RegisteredModel,
) (*openapi.RegisteredModel, error) {
    // Convert domain model to OpenAPI
    model, err := m.embedMDConverter.FromRegisteredModel(entity)
    if err != nil {
        return nil, err
    }

    // Convert ID to string
    if entity.ID != nil {
        id := strconv.Itoa(int(*entity.ID))
        model.Id = &id
    }

    // Convert custom properties
    if entity.CustomProperties != nil {
        model.CustomProperties = m.convertToOpenAPICustomProperties(entity.CustomProperties)
    }

    return model, nil
}
```

## Custom Property Conversion

### OpenAPI to Domain

```go
func (m *EmbedMDMapper) convertCustomProperties(
    props map[string]openapi.MetadataValue,
) []models.Properties {
    var result []models.Properties

    for name, value := range props {
        prop := models.Properties{
            Name:             name,
            IsCustomProperty: true,
        }

        switch v := value.ActualInstance.(type) {
        case *openapi.MetadataStringValue:
            prop.StringValue = &v.StringValue
        case *openapi.MetadataIntValue:
            intVal := int32(v.IntValue)
            prop.IntValue = &intVal
        case *openapi.MetadataDoubleValue:
            prop.DoubleValue = &v.DoubleValue
        case *openapi.MetadataBoolValue:
            prop.BoolValue = &v.BoolValue
        }

        result = append(result, prop)
    }

    return result
}
```

### Domain to OpenAPI

```go
func (m *EmbedMDMapper) convertToOpenAPICustomProperties(
    props *[]models.Properties,
) map[string]openapi.MetadataValue {
    result := make(map[string]openapi.MetadataValue)

    for _, prop := range *props {
        if !prop.IsCustomProperty {
            continue
        }

        var value openapi.MetadataValue

        if prop.StringValue != nil {
            value.ActualInstance = &openapi.MetadataStringValue{
                MetadataType: "MetadataStringValue",
                StringValue:  *prop.StringValue,
            }
        } else if prop.IntValue != nil {
            value.ActualInstance = &openapi.MetadataIntValue{
                MetadataType: "MetadataIntValue",
                IntValue:     int64(*prop.IntValue),
            }
        } else if prop.DoubleValue != nil {
            value.ActualInstance = &openapi.MetadataDoubleValue{
                MetadataType: "MetadataDoubleValue",
                DoubleValue:  *prop.DoubleValue,
            }
        } else if prop.BoolValue != nil {
            value.ActualInstance = &openapi.MetadataBoolValue{
                MetadataType: "MetadataBoolValue",
                BoolValue:    *prop.BoolValue,
            }
        }

        result[prop.Name] = value
    }

    return result
}
```

## Reconciler Pattern

For update operations, reconcile existing values with updates:

```go
// goverter:converter
type OpenAPIReconciler interface {
    // Merge update into existing, preserving unset fields
    // goverter:default ExistingModel
    // goverter:autoMap ExistingModel
    ReconcileRegisteredModel(
        ExistingModel *openapi.RegisteredModel,
        UpdateModel *openapi.RegisteredModelUpdate,
    ) (*openapi.RegisteredModel, error)
}
```

## ID Conversion

### String to Int32

```go
func StringToInt32(s string) (int32, error) {
    i, err := strconv.ParseInt(s, 10, 32)
    if err != nil {
        return 0, fmt.Errorf("%w: invalid id format: %s", api.ErrBadRequest, s)
    }
    return int32(i), nil
}
```

### Int32 to String

```go
func Int32ToString(i int32) string {
    return strconv.FormatInt(int64(i), 10)
}
```

## Error Handling

```go
func (m *EmbedMDMapper) MapFromRegisteredModel(
    registeredModel *openapi.RegisteredModel,
) (*models.RegisteredModel, error) {
    if registeredModel == nil {
        return nil, fmt.Errorf("%w: registered model is nil", api.ErrBadRequest)
    }

    entity, err := m.openAPIConverter.ToRegisteredModel(registeredModel)
    if err != nil {
        return nil, fmt.Errorf("failed to convert registered model: %w", err)
    }

    return entity, nil
}
```

## Testing

```go
func TestMapFromRegisteredModel(t *testing.T) {
    mapper := NewEmbedMDMapper(map[string]int32{
        "odh.RegisteredModel": 1,
    })

    model := &openapi.RegisteredModel{
        Name:        ptr("test-model"),
        Description: ptr("Test description"),
        CustomProperties: map[string]openapi.MetadataValue{
            "key": {
                ActualInstance: &openapi.MetadataStringValue{
                    StringValue: "value",
                },
            },
        },
    }

    result, err := mapper.MapFromRegisteredModel(model)

    assert.NoError(t, err)
    assert.Equal(t, "test-model", *result.Attributes.Name)
    assert.Equal(t, int32(1), *result.TypeID)
    assert.Len(t, *result.CustomProperties, 1)
}
```

---

[Back to Backend Index](./README.md) | [Previous: Database Layer](./database-layer.md) | [Next: Middleware](./middleware.md)
