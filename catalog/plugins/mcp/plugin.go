// Code generated by catalog-gen. DO NOT EDIT.
// To regenerate: catalog-gen generate
// Source: catalog.yaml
//
// Package mcp provides the McpServer catalog plugin for the unified catalog server.
package mcp

import (
	"context"
	"fmt"
	"log/slog"
	"path/filepath"
	"reflect"
	"sync/atomic"

	"github.com/go-chi/chi/v5"
	"gorm.io/gorm"

	"github.com/kubeflow/model-registry/catalog/plugins/mcp/internal/catalog"
	"github.com/kubeflow/model-registry/catalog/plugins/mcp/internal/catalog/providers"
	"github.com/kubeflow/model-registry/catalog/plugins/mcp/internal/db/models"
	"github.com/kubeflow/model-registry/catalog/plugins/mcp/internal/db/service"
	"github.com/kubeflow/model-registry/catalog/plugins/mcp/internal/server/openapi"
	"github.com/kubeflow/model-registry/internal/datastore"
	"github.com/kubeflow/model-registry/internal/datastore/embedmd"
	pkgcatalog "github.com/kubeflow/model-registry/pkg/catalog"
	"github.com/kubeflow/model-registry/pkg/catalog/plugin"
)

const (
	// PluginName is the identifier for this plugin.
	PluginName = "mcp"

	// PluginVersion is the API version.
	PluginVersion = "v1alpha1"
)

// McpServerCatalogPlugin implements the CatalogPlugin interface for McpServer catalogs.
type McpServerCatalogPlugin struct {
	cfg      plugin.Config
	logger   *slog.Logger
	loader   *catalog.Loader
	services service.Services
	healthy  atomic.Bool
	started  atomic.Bool
}

// Name returns the plugin name.
func (p *McpServerCatalogPlugin) Name() string {
	return PluginName
}

// Version returns the plugin API version.
func (p *McpServerCatalogPlugin) Version() string {
	return PluginVersion
}

// Description returns a human-readable description.
func (p *McpServerCatalogPlugin) Description() string {
	return "McpServer catalog"
}

// BasePath returns the API base path for this plugin.
func (p *McpServerCatalogPlugin) BasePath() string {
	return "/api/mcp_catalog/v1alpha1"
}

// Init initializes the plugin with configuration.
func (p *McpServerCatalogPlugin) Init(ctx context.Context, cfg plugin.Config) error {
	p.cfg = cfg
	p.logger = cfg.Logger
	if p.logger == nil {
		p.logger = slog.Default()
	}

	p.logger.Info("initializing mcp plugin")

	// Build config paths from source loaderConfigPath overrides only.
	// Legacy loader config files have a flat "catalogs:" format that differs
	// from the framework's sources.yaml (apiVersion/kind). If no explicit
	// loaderConfigPath is set, we inject framework sources directly instead.
	var loaderPaths []string
	pathsSet := make(map[string]bool)
	for _, src := range cfg.Section.Sources {
		if loaderPath, ok := src.Properties["loaderConfigPath"].(string); ok && loaderPath != "" {
			if !filepath.IsAbs(loaderPath) && src.Origin != "" {
				loaderPath = filepath.Join(filepath.Dir(src.Origin), loaderPath)
			}
			if !pathsSet[loaderPath] {
				loaderPaths = append(loaderPaths, loaderPath)
				pathsSet[loaderPath] = true
			}
		}
	}

	// Initialize services from the database connection
	services, err := p.initServices(cfg.DB)
	if err != nil {
		return fmt.Errorf("failed to initialize services: %w", err)
	}
	p.services = services

	// Set up provider registry
	registry := pkgcatalog.NewProviderRegistry[models.McpServer, any]()
	if err := registry.Register("yaml", providers.NewMcpServerYAMLProvider()); err != nil {
		return fmt.Errorf("failed to register YAML provider: %w", err)
	}

	// Create the loader (with explicit loader config paths, or empty)
	p.loader = catalog.NewLoader(services, loaderPaths, registry)

	// When no loader config files are specified, inject framework sources
	// directly into the loader's SourceCollection. This uses the source
	// definitions from sources.yaml as parsed by the plugin framework.
	if len(loaderPaths) == 0 && len(cfg.Section.Sources) > 0 {
		frameworkSources := make(map[string]pkgcatalog.Source, len(cfg.Section.Sources))
		for _, src := range cfg.Section.Sources {
			origin := src.Origin
			if origin == "" && len(cfg.ConfigPaths) > 0 {
				origin = cfg.ConfigPaths[0]
			}
			frameworkSources[src.ID] = pkgcatalog.Source{
				ID:         src.ID,
				Name:       src.Name,
				Type:       src.Type,
				Enabled:    src.Enabled,
				Labels:     src.Labels,
				Properties: src.Properties,
				Origin:     origin,
			}
		}
		if err := p.loader.Sources.Merge("framework", frameworkSources); err != nil {
			return fmt.Errorf("failed to inject framework sources: %w", err)
		}
	}

	p.logger.Info("mcp plugin initialized", "loaderPaths", loaderPaths, "frameworkSources", len(cfg.Section.Sources))
	return nil
}

// initServices creates the service layer from the database connection.
func (p *McpServerCatalogPlugin) initServices(db *gorm.DB) (service.Services, error) {
	spec := service.DatastoreSpec()

	connector, err := datastore.NewConnector("embedmd", &embedmd.EmbedMDConfig{DB: db})
	if err != nil {
		return service.Services{}, fmt.Errorf("failed to create connector: %w", err)
	}

	repoSet, err := connector.Connect(spec)
	if err != nil {
		return service.Services{}, fmt.Errorf("failed to connect: %w", err)
	}

	repo, err := getRepository[models.McpServerRepository](repoSet)
	if err != nil {
		return service.Services{}, fmt.Errorf("failed to get McpServer repository: %w", err)
	}

	return service.NewServices(repo), nil
}

// Start begins background operations (hot-reload, watchers).
func (p *McpServerCatalogPlugin) Start(ctx context.Context) error {
	p.logger.Info("starting mcp plugin")

	if err := p.loader.Start(ctx); err != nil {
		return fmt.Errorf("failed to start loader: %w", err)
	}

	p.started.Store(true)
	p.healthy.Store(true)

	p.logger.Info("mcp plugin started")
	return nil
}

// Stop gracefully shuts down the plugin.
func (p *McpServerCatalogPlugin) Stop(ctx context.Context) error {
	p.logger.Info("stopping mcp plugin")
	p.started.Store(false)
	p.healthy.Store(false)
	return nil
}

// Healthy returns true if the plugin is functioning correctly.
func (p *McpServerCatalogPlugin) Healthy() bool {
	return p.healthy.Load()
}

// RegisterRoutes mounts the plugin's HTTP routes on the provided router.
func (p *McpServerCatalogPlugin) RegisterRoutes(router chi.Router) error {
	p.logger.Info("registering mcp routes")

	// Create the OpenAPI service
	apiService := openapi.NewMcpServerCatalogServiceAPIService(p.services)
	apiController := openapi.NewDefaultAPIController(apiService)

	// Mount routes - remove the base path prefix since chi.Router already handles that
	basePath := "/api/mcp_catalog/v1alpha1"
	for _, route := range apiController.OrderedRoutes() {
		pattern := route.Pattern
		if len(pattern) > len(basePath) && pattern[:len(basePath)] == basePath {
			pattern = pattern[len(basePath):]
		}
		if pattern == "" {
			pattern = "/"
		}
		router.Method(route.Method, pattern, route.HandlerFunc)
		p.logger.Debug("registered route", "method", route.Method, "pattern", pattern)
	}

	return nil
}

// Migrations returns database migrations for this plugin.
func (p *McpServerCatalogPlugin) Migrations() []plugin.Migration {
	// Migrations are handled by the datastore layer
	return nil
}

// getRepository extracts a repository of type T from the RepoSet.
func getRepository[T any](rs datastore.RepoSet) (T, error) {
	var zero T
	t := reflect.TypeFor[T]()

	repo, err := rs.Repository(t)
	if err != nil {
		return zero, err
	}

	result, ok := repo.(T)
	if !ok {
		return zero, fmt.Errorf("repository type mismatch: expected %T, got %T", zero, repo)
	}

	return result, nil
}
