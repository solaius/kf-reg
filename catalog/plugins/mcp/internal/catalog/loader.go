// Code generated by catalog-gen. DO NOT EDIT.
// To regenerate: catalog-gen generate
// Source: catalog.yaml

package catalog

import (
	"context"

	"github.com/golang/glog"
	"github.com/kubeflow/model-registry/pkg/catalog"
	sharedmodels "github.com/kubeflow/model-registry/internal/db/models"
	"github.com/kubeflow/model-registry/catalog/plugins/mcp/internal/db/models"
	"github.com/kubeflow/model-registry/catalog/plugins/mcp/internal/db/service"
)

// glogLogger implements catalog.LoaderLogger using glog.
type glogLogger struct{}

func (glogLogger) Infof(format string, args ...any)  { glog.Infof(format, args...) }
func (glogLogger) Errorf(format string, args ...any) { glog.Errorf(format, args...) }

// Loader wraps the generic catalog loader with McpServer-specific types.
type Loader struct {
	*catalog.Loader[models.McpServer, any]
	services service.Services
}

// NewLoader creates a new catalog loader.
func NewLoader(services service.Services, paths []string, registry *catalog.ProviderRegistry[models.McpServer, any]) *Loader {
	cfg := catalog.LoaderConfig[models.McpServer, any]{
		Paths:            paths,
		ProviderRegistry: registry,
		Logger:           glogLogger{},
		SaveEntity: func(entity models.McpServer) (models.McpServer, error) {
			return services.McpServerRepository.Save(entity)
		},
		SaveArtifact: saveArtifact(services),
		GetEntityID: func(entity models.McpServer) *int32 {
			return entity.GetID()
		},
		GetEntityName: func(entity models.McpServer) string {
			if attrs := entity.GetAttributes(); attrs != nil && attrs.Name != nil {
				return *attrs.Name
			}
			return ""
		},
		DeleteArtifactsByEntity: deleteArtifactsByEntity(services),
		DeleteEntitiesBySource: func(sourceID string) error {
			return services.McpServerRepository.DeleteBySource(sourceID)
		},
		GetDistinctSourceIDs: func() ([]string, error) {
			return services.McpServerRepository.GetDistinctSourceIDs()
		},
		SetEntitySourceID: func(entity models.McpServer, sourceID string) {
			setEntitySourceID(entity, sourceID)
		},
		IsEntityNil: func(entity models.McpServer) bool {
			return entity == nil
		},
	}

	return &Loader{
		Loader:   catalog.NewLoader(cfg),
		services: services,
	}
}

// saveArtifact returns a function that saves an artifact to the appropriate repository.
func saveArtifact(services service.Services) func(artifact any, entityID int32) error {
	return func(artifact any, entityID int32) error {
		// No artifacts configured
		return nil
	}
}

// deleteArtifactsByEntity returns a function that deletes all artifacts for an entity.
func deleteArtifactsByEntity(services service.Services) func(entityID int32) error {
	return func(entityID int32) error {
		return nil
	}
}

// Start begins loading catalog data.
func (l *Loader) Start(ctx context.Context) error {
	return l.Loader.Start(ctx)
}

// setEntitySourceID sets the source_id as a property on the entity.
// This follows the MLMD pattern where source_id is stored as a ContextProperty.
func setEntitySourceID(entity models.McpServer, sourceID string) {
	props := entity.GetProperties()
	if props == nil {
		newProps := []sharedmodels.Properties{}
		props = &newProps
	}

	// Check if source_id already exists
	for i := range *props {
		if (*props)[i].Name == "source_id" {
			(*props)[i].StringValue = &sourceID
			return
		}
	}

	// Add new source_id property
	*props = append(*props, sharedmodels.Properties{
		Name:        "source_id",
		StringValue: &sourceID,
	})
}
