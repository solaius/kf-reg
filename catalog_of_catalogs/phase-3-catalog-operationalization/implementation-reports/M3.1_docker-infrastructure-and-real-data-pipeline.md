# M3.1: Docker Infrastructure and Real Data Pipeline

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 3: Catalog Operationalization

## Summary

This milestone established the container infrastructure and data pipeline to run the catalog-server in real mode with PostgreSQL and real MCP server data loaded from YAML files. A dedicated `Dockerfile.catalog-server` multi-stage build produces both `catalog-server` and `catalog-cli` binaries, while `docker-compose.catalog.yaml` orchestrates PostgreSQL 16 and the catalog-server with health checks and volume mounts. The key challenge was YAML path resolution: the Loader resolves `yamlCatalogPath` relative to the config file's directory (`filepath.Dir(source.Origin)`), so container volume mounts must preserve the relative path structure between config files and data files. A dual config format bridges the management-plane API config (`sources.yaml`) and the flat Loader-compatible format (`mcp-loader-config.yaml`).

## Motivation

- The Phase 1 Docker Compose stack (M6) used the general `Dockerfile` which builds both `model-registry` and `catalog-server` in one image. A dedicated `Dockerfile.catalog-server` provides a smaller, purpose-built image for catalog-only deployments.
- Phase 2 development relied on BFF mock data. Moving to real mode requires a running catalog-server with a real database and real YAML data files.
- The YAML provider's path resolution behavior (relative to config file directory) needed explicit handling in Docker volume mounts to avoid data loading failures at startup.
- Operators need a one-command dev stack (`docker compose up`) that loads production-representative MCP server data for integration testing and UI development against real endpoints.

## What Changed

### Files Created

| File | Purpose |
|------|---------|
| `Dockerfile.catalog-server` | Multi-stage Docker build (Go 1.24 builder + distroless runtime) for `catalog-server` and `catalog-cli` binaries, with config and data files COPYed preserving relative path structure |
| `docker-compose.catalog.yaml` | Docker Compose stack: PostgreSQL 16 with health checks + catalog-server with DB DSN, source config, and read-only volume mounts |
| `catalog/config/sources.yaml` | Production source configuration in `apiVersion: catalog/v1alpha1` format defining the MCP default source with YAML provider and `loaderConfigPath` pointer |
| `catalog/config/mcp-loader-config.yaml` | Loader-format config for MCP plugin (flat `catalogs[]` array format the Loader expects, separate from the management-plane API format) |
| `catalog/plugins/mcp/data/mcp-servers.yaml` | Production YAML data with 6 real MCP server entries covering local/remote modes, multiple providers, and categories |

## How It Works

### Docker Path Structure

The Loader resolves `yamlCatalogPath` relative to the config file's directory using `filepath.Dir(source.Origin)`. This means the relative path relationship between config files and data files must be preserved in the container:

```
Container filesystem:
/config/sources.yaml                       # Management-plane config
/config/mcp-loader-config.yaml             # Loader-format config
/plugins/mcp/data/mcp-servers.yaml         # MCP server data

Resolution:
  sources.yaml contains: yamlCatalogPath: "../plugins/mcp/data/mcp-servers.yaml"
  filepath.Dir("/config/sources.yaml") = "/config/"
  "/config/" + "../plugins/mcp/data/mcp-servers.yaml" = "/plugins/mcp/data/mcp-servers.yaml"
```

Volume mounts in Docker Compose mirror this structure:
- `./catalog/config:/config:ro` -- config files at `/config/`
- `./catalog/plugins/mcp/data:/plugins/mcp/data:ro` -- data files at `/plugins/mcp/data/`

### Dual Config Format

The management-plane API config uses a hierarchical format with `apiVersion` and `kind` headers:

```yaml
# catalog/config/sources.yaml
apiVersion: catalog/v1alpha1
kind: CatalogSources
catalogs:
  mcp:
    sources:
      - id: mcp-default
        name: "MCP Servers"
        type: yaml
        enabled: true
        labels: ["MCP Servers"]
        properties:
          yamlCatalogPath: "../plugins/mcp/data/mcp-servers.yaml"
          loaderConfigPath: "./mcp-loader-config.yaml"
```

The Loader expects a flat `catalogs[]` array without the `apiVersion`/`kind` wrapper:

```yaml
# catalog/config/mcp-loader-config.yaml
catalogs:
  - id: mcp-default
    name: "MCP Servers"
    type: yaml
    enabled: true
    labels: ["MCP Servers"]
    properties:
      yamlCatalogPath: "../plugins/mcp/data/mcp-servers.yaml"
```

The `loaderConfigPath` property in `sources.yaml` points to `mcp-loader-config.yaml`, which provides the Loader-compatible format. This avoids requiring the Loader to understand the management API config structure.

### MCP Server Data (6 entries)

The `mcp-servers.yaml` file contains 6 production-representative MCP server entries:

| Server | Mode | Provider | Category | License | Transport | Tools | Resources | Prompts |
|--------|------|----------|----------|---------|-----------|-------|-----------|---------|
| kubernetes-mcp-server | local | Red Hat | Red Hat | Apache-2.0 | stdio, http | 12 | 8 | 3 |
| openshift-mcp-server | local | Red Hat | Red Hat | Apache-2.0 | stdio, http | 15 | 10 | 4 |
| ansible-mcp-server | local | Red Hat | Red Hat | Apache-2.0 | stdio | 8 | 5 | 2 |
| postgres-mcp-server | local | Crunchy Data | Database | PostgreSQL | stdio | 10 | 6 | 1 |
| github-mcp-server | remote | GitHub | DevOps | MIT | http, sse | 20 | 15 | 5 |
| jira-mcp-server | remote | Atlassian | DevOps | Apache-2.0 | http | 12 | 8 | 3 |

This dataset provides coverage across: 2 deployment modes (local/remote), 4 providers (Red Hat, Crunchy Data, GitHub, Atlassian), 3 categories (Red Hat, Database, DevOps), 3 licenses (Apache-2.0, PostgreSQL, MIT), and 3 transports (stdio, http, sse). All entries include verified/certified flags, container image references, and realistic tool/resource/prompt counts.

### Dockerfile

Multi-stage build with Go 1.24:

```dockerfile
# Stage 1: Builder
FROM --platform=$BUILDPLATFORM golang:1.24 AS builder
WORKDIR /workspace
COPY go.mod go.sum ./
COPY pkg/openapi/go.mod pkg/openapi/
COPY catalog/pkg/openapi/go.mod catalog/pkg/openapi/
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 go build -buildvcs=false -o catalog-server ./cmd/catalog-server
RUN CGO_ENABLED=0 go build -buildvcs=false -o catalog-cli ./cmd/catalog

# Stage 2: Runtime (distroless)
FROM gcr.io/distroless/static:nonroot
COPY --from=builder /workspace/catalog-server .
COPY --from=builder /workspace/catalog-cli .
COPY catalog/config/ /config/
COPY catalog/plugins/mcp/data/ /plugins/mcp/data/
USER 65532:65532
EXPOSE 8080
ENTRYPOINT ["/catalog-server"]
```

Config and data files are COPYed into the image as defaults, but Docker Compose overrides them with bind mounts for development (enabling live file changes without rebuilds).

### Docker Compose

```yaml
services:
  postgres:
    image: postgres:16
    container_name: catalog-postgres
    environment:
      POSTGRES_DB: catalog
      POSTGRES_USER: catalog
      POSTGRES_PASSWORD: catalog
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U catalog -d catalog"]
      interval: 5s
      timeout: 5s
      retries: 5

  catalog-server:
    build:
      context: .
      dockerfile: Dockerfile.catalog-server
    container_name: catalog-server
    command:
      - --listen=:8080
      - --sources=/config/sources.yaml
      - --db-type=postgres
      - --db-dsn=postgres://catalog:catalog@postgres:5432/catalog?sslmode=disable
    volumes:
      - ./catalog/config:/config:ro
      - ./catalog/plugins/mcp/data:/plugins/mcp/data:ro
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "8080:8080"
    healthcheck:
      test: ["CMD", "/catalog-server", "--help"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 15s
```

The `depends_on` condition ensures PostgreSQL is fully ready before the catalog-server starts. The catalog-server health check uses `--help` as a liveness probe (exits 0 immediately).

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Preserve relative path structure in Docker | Loader resolves `yamlCatalogPath` relative to config dir via `filepath.Dir(source.Origin)`; breaking this structure breaks data loading | Absolute paths in container (requires config changes per environment) |
| Separate loader config file (`mcp-loader-config.yaml`) | Management API config uses `apiVersion`/`kind` header format; Loader expects flat `catalogs[]` array format | Single config format (requires Loader to understand management API format, breaking existing Loader contract) |
| Dedicated `Dockerfile.catalog-server` | Purpose-built image without `model-registry` binary; smaller image, clearer intent | Reuse existing Dockerfile with entrypoint override (larger image, includes unnecessary binaries) |
| 6 real MCP entries (no Slack) | Representative mix of local/remote modes, different providers (4), categories (3), and licenses (3); sufficient filter coverage for UI testing | More entries (unnecessary for MVP), fewer entries (insufficient filter/category coverage) |
| PostgreSQL 16 in compose | Production-grade DB; matches deployment target; consistent with existing compose patterns in repo | SQLite (simpler but not production-representative), MySQL (supported but PostgreSQL is primary target) |
| Read-only volume mounts (`:ro`) | Defense-in-depth; config and data should not be modified by the running container in normal operation | Read-write mounts (needed for YAML write-back from UI, but not required for this milestone) |
| Distroless runtime image | Minimal attack surface; no shell, no package manager; follows security best practices | Alpine (has shell for debugging but larger attack surface), scratch (no user support) |

## Testing

### Build Verification

```bash
# Dockerfile builds successfully
docker build -f Dockerfile.catalog-server -t catalog-server:dev .

# Binaries are present in the image
docker run --rm catalog-server:dev /catalog-server --help
docker run --rm catalog-server:dev /catalog-cli --help
```

### Go Tests

All existing tests continue to pass:

```bash
# Plugin framework tests
go test ./pkg/catalog/plugin/... -v -count=1

# MCP plugin tests (including YAML provider)
go test ./catalog/plugins/mcp/... -v -count=1
```

## Verification

```bash
# Start the stack
docker compose -f docker-compose.catalog.yaml up -d --build

# Wait for services
docker compose -f docker-compose.catalog.yaml ps
# Both postgres and catalog-server should show "healthy"

# Verify catalog-server loaded data
curl -s http://localhost:8080/api/mcp_catalog/v1alpha1/mcpservers | python3 -m json.tool | head -20

# Verify 6 entries
curl -s http://localhost:8080/api/mcp_catalog/v1alpha1/mcpservers | python3 -c "import sys,json; print(json.load(sys.stdin)['size'])"
# Output: 6

# Verify individual server retrieval
curl -s http://localhost:8080/api/mcp_catalog/v1alpha1/mcpservers/kubernetes-mcp-server | python3 -m json.tool

# Verify sources endpoint
curl -s http://localhost:8080/api/mcp_catalog/v1alpha1/sources | python3 -m json.tool

# Verify plugin discovery
curl -s http://localhost:8080/api/plugins | python3 -m json.tool

# Verify filtering works
curl -s "http://localhost:8080/api/mcp_catalog/v1alpha1/mcpservers?filterQuery=deploymentMode='local'" | python3 -c "import sys,json; print(json.load(sys.stdin)['size'])"
# Output: 4

curl -s "http://localhost:8080/api/mcp_catalog/v1alpha1/mcpservers?filterQuery=category='DevOps'" | python3 -c "import sys,json; print(json.load(sys.stdin)['size'])"
# Output: 2

# Tear down
docker compose -f docker-compose.catalog.yaml down -v
```

## Dependencies & Impact

- **Depends on**: Phase 1 plugin framework (M1), Phase 1 MCP plugin implementation (M2), Phase 1 Docker Compose with catalog-server (M6)
- **Enables**: M3.2 (BFF real wiring -- BFF can now point to a real catalog-server instead of mock data), M3.3 (MCP real data and provider validation -- data pipeline is established), M3.4 (UI operational hardening -- real endpoints for status/diagnostics)
- **No backward compatibility concerns**: All files created are new; no existing files were modified. The existing `Dockerfile` and `docker-compose-local.yaml` remain unchanged.

## Open Items

- Volume mounts are read-only (`:ro`); enabling YAML write-back from UI management pages requires removing `:ro` from the data mount and implementing file write support in the YAML provider.
- No TLS configuration in Docker Compose; acceptable for local development but production deployments will need TLS termination (likely via ingress or sidecar proxy).
- Health check for catalog-server uses `--help` flag as a liveness probe; a dedicated `/healthz` or `/readyz` HTTP endpoint would be more appropriate and is tracked for M3.4.
- The `catalog-cli` binary is included in the image but not exercised by Docker Compose; it is available for ad-hoc debugging via `docker exec`.
- PostgreSQL data is ephemeral (no named volume); `docker compose down -v` destroys all data. For persistent development data, a named volume could be added.
