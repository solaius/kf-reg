# M3.4: UI Operational Hardening

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 3: Catalog Operationalization

## Summary

This milestone transformed the Manage Source page from a mostly non-functional shell into a fully wired management experience. The key challenge was that file-based sources store a server-side `yamlCatalogPath` (not inline content), so the backend needed to resolve the path, read the file, and return the content in the API response. On save, edited content is written back to the file. The frontend now shows the full YAML content in a vertically resizable textarea, with source metadata in a sidebar details panel. Additionally, the diagnostics page crash when `sources` is undefined was fixed, and styling issues on the source config form were resolved.

## Files Created

| File | Purpose |
|------|---------|
| `clients/ui/frontend/src/app/pages/catalogManagement/screens/PluginSourceConfigPage.css` | CSS for vertically resizable YAML textarea (`resize: vertical !important; min-height: 200px`) |

## Files Modified

| File | Change |
|------|--------|
| `catalog/plugins/mcp/management.go` | `ListSources()`: reads YAML file content via `os.ReadFile()` and includes as `content` property. `ApplySource()`: writes edited content back to YAML file via `os.WriteFile()`, preserves source origin for path resolution. Added `resolveSourcePath()` helper. |
| `clients/ui/frontend/src/app/pages/catalogManagement/screens/PluginSourceConfigPage.tsx` | Complete overhaul: added `type="text"` to TextInput for visible borders; shows YAML file path label above textarea; textarea pre-populated with real YAML content from server; sidebar panel shows source details (status, type, entity count, labels, source ID) in manage mode; submit handler preserves `yamlCatalogPath` in properties |
| `clients/ui/frontend/src/app/pages/catalogManagement/screens/PluginDiagnosticsPage.tsx` | Added null guard for `diagnostics.sources` to prevent crash when sources array is undefined |

## How It Works

### Backend: YAML content read/write in management.go

`ListSources()` enriches source properties with file content:
```go
// Copy properties so we can enrich without mutating the original.
props := make(map[string]any, len(src.Properties))
for k, v := range src.Properties {
    props[k] = v
}

// For YAML sources with a file path, read the file content.
if yamlPath, ok := props["yamlCatalogPath"].(string); ok && yamlPath != "" {
    resolvedPath := resolveSourcePath(src, yamlPath)
    if data, err := os.ReadFile(resolvedPath); err == nil {
        props["content"] = string(data)
    }
}
```

`ApplySource()` writes content back to the YAML file:
```go
if content, ok := src.Properties["content"].(string); ok && content != "" {
    if yamlPath, ok := src.Properties["yamlCatalogPath"].(string); ok && yamlPath != "" {
        existingSource, exists := p.loader.Sources.AllSources()[src.ID]
        if exists {
            resolved := resolveSourcePath(existingSource, yamlPath)
            if err := os.WriteFile(resolved, []byte(content), 0644); err != nil {
                return fmt.Errorf("failed to write YAML file %s: %w", resolved, err)
            }
        }
    }
}
// Don't persist inline content in source properties -- the file is the source of truth.
delete(src.Properties, "content")
```

Path resolution helper:
```go
func resolveSourcePath(src pkgcatalog.Source, path string) string {
    if filepath.IsAbs(path) {
        return path
    }
    if src.Origin != "" {
        return filepath.Join(filepath.Dir(src.Origin), path)
    }
    return path
}
```

### Frontend: Manage Source page (PluginSourceConfigPage.tsx)

State variables added:
```tsx
const [yamlCatalogPath, setYamlCatalogPath] = React.useState<string | undefined>();
const [sourceLabels, setSourceLabels] = React.useState<string[]>([]);
const [entityCount, setEntityCount] = React.useState(0);
```

Data loading from API:
```tsx
// Load YAML content from properties
const content = source.properties?.content;
if (typeof content === 'string') {
    setYamlContent(content);
}
// Track the YAML catalog path for file-based sources
const catalogPath = source.properties?.yamlCatalogPath;
if (typeof catalogPath === 'string') {
    setYamlCatalogPath(catalogPath);
}
```

Sidebar details panel (manage mode):
- Status: Enabled/Disabled with color-coded Label (green/grey)
- Source type: displayed with blue Label
- Entities: count + entity label (e.g., "6 servers")
- Labels: LabelGroup with source labels
- Source ID: monospace code display

### Diagnostics null guard

```tsx
// Before (crashed on undefined sources):
{diagnostics.sources.length === 0 ? (

// After:
{!diagnostics.sources || diagnostics.sources.length === 0 ? (
```

### CSS for resizable textarea

```css
.plugin-source-config__yaml-upload textarea {
  resize: vertical !important;
  min-height: 200px;
}
```

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Read file content in ListSources, not a separate endpoint | Keeps API surface small; content is needed every time sources are listed for management | Dedicated `/sources/:id/content` endpoint (more REST-ful but adds complexity) |
| Delete `content` from properties before persisting | File is the source of truth; storing content in both file and properties creates inconsistency | Keep content in properties (duplicates data, risks drift) |
| Preserve source origin on ApplySource | Path resolution depends on origin directory; losing origin breaks `yamlCatalogPath` resolution | Always use "api" origin (breaks relative path resolution for file-based sources) |
| `!important` on textarea resize | PatternFly sets `resize: none` on textareas; override needed for user control | Custom PatternFly variant (heavier change for simple UX fix) |
| Show file path label above textarea | Users need context about where the file lives on the server | Hide path (users lose context about server-side file location) |

## Testing

```bash
# Verify sources endpoint returns YAML content
curl -s "http://localhost:8080/api/mcp_catalog/v1alpha1/sources" | python3 -c "
import sys,json
s = json.load(sys.stdin)['sources'][0]
p = s.get('properties',{})
print('has content:', 'content' in p)
print('content length:', len(p.get('content','')))
print('yamlCatalogPath:', p.get('yamlCatalogPath',''))
"
# Output:
# has content: True
# content length: 4098
# yamlCatalogPath: ../plugins/mcp/data/mcp-servers.yaml

# Verify BFF passes content through
curl -s "http://localhost:4000/api/v1/catalog/mcp/sources?namespace=default" | python3 -c "
import sys,json
s = json.load(sys.stdin)['data']['sources'][0]
print('content starts with:', str(s['properties']['content'])[:50])
"
# Output: content starts with: mcpservers:
#   - name: "kubernetes-mcp-server"
```

## Dependencies & Impact

- **Depends on**: M3.1 (Docker infrastructure), M3.2 (BFF real wiring), M3.3 (entity count bridge)
- This is the culmination of Phase 3 -- the UI now operates against real data end-to-end
- YAML write-back requires the Docker volume mount to be writable (remove `:ro` from data mount)

## Open Items

- No YAML syntax validation in the frontend textarea before save
- No confirmation dialog before overwriting server-side YAML file
- Large YAML files may impact API response size (content is returned inline)
- Frontend does not auto-refresh after save to show updated entity counts (requires manual navigation back to sources page)
