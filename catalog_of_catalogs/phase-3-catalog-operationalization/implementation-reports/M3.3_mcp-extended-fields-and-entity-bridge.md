# M3.3: MCP Extended Fields & Entity Count Bridge

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 3: Catalog Operationalization

## Summary

This milestone closed two gaps in the real-mode data pipeline. First, the MCP API response was missing 10 extended fields (deploymentMode, image, endpoint, supportedTransports, license, verified, certified, provider, logo, category) that were stored in the database but never extracted by the converter function -- a three-layer fix spanning OpenAPI spec, Go models, and the property extraction switch. Second, the source management layer reported 0 entities for all sources because `ListSources()` and `Diagnostics()` never queried the database for entity counts. Adding `CountBySource()` to the repository and calling it from management methods bridged this gap.

## Motivation

- The MCP data model defined 15 properties in `catalog.yaml`, but the API response only returned the 5 basic ones (description, serverUrl, transportType, toolCount, resourceCount). The remaining 10 fields (deploymentMode, image, endpoint, supportedTransports, license, verified, certified, provider, logo, category) were ingested into the database by the YAML provider but silently dropped during the conversion from database entity to OpenAPI response.
- The source management endpoints (`ListSources`, `Diagnostics`) returned `entityCount: 0` for every source, making it impossible for the UI or CLI to show how many MCP servers belong to each configured source.
- Both gaps blocked the UI gallery from showing deployment badges, provider information, and category filters, and prevented the sources management table from displaying meaningful entity counts.

## Files Modified

| File | Change |
|------|--------|
| `catalog/plugins/mcp/api/openapi/openapi.yaml` | Added 10 missing properties to McpServer schema: deploymentMode, image, endpoint, supportedTransports, license, verified, certified, provider, logo, category |
| `catalog/plugins/mcp/internal/server/openapi/models.go` | Added 10 corresponding Go struct fields to McpServer type with JSON tags |
| `catalog/plugins/mcp/internal/server/openapi/api_mcpserver_service_impl.go` | Added 10 case statements to `convertToOpenAPIModel()` property extraction switch |
| `catalog/plugins/mcp/internal/db/models/mcpserver.go` | Added `CountBySource(sourceID string) (int, error)` to McpServerRepository interface |
| `catalog/plugins/mcp/internal/db/service/mcpserver.go` | Implemented `CountBySource()` method with SQL query joining Context and ContextProperty tables |
| `catalog/plugins/mcp/management.go` | Called `CountBySource()` in `ListSources()` and `Diagnostics()` to populate entity counts |

## How It Works

### Three-layer API field fix

The MCP data model stores properties in a key-value property table (ContextProperty). The API response pipeline has three layers that must all be in sync:

1. **OpenAPI spec** (`openapi.yaml`) -- defines which fields the API returns
2. **Go model** (`models.go`) -- Go struct with JSON tags for serialization
3. **Converter** (`api_mcpserver_service_impl.go`) -- extracts properties from DB and maps to struct fields

Before the fix, only 5 basic properties were handled (description, serverUrl, transportType, toolCount, resourceCount). After the fix, all 15 properties are handled. The promptCount field was also already present in the model but previously unextracted.

```go
// api_mcpserver_service_impl.go -- property extraction (excerpt of the added cases)
case "deploymentMode":
    if prop.StringValue != nil {
        result.DeploymentMode = *prop.StringValue
    }
case "image":
    if prop.StringValue != nil {
        result.Image = *prop.StringValue
    }
case "endpoint":
    if prop.StringValue != nil {
        result.Endpoint = *prop.StringValue
    }
case "supportedTransports":
    if prop.StringValue != nil {
        result.SupportedTransports = *prop.StringValue
    }
case "license":
    if prop.StringValue != nil {
        result.License = *prop.StringValue
    }
case "verified":
    if prop.BoolValue != nil {
        v := *prop.BoolValue
        result.Verified = &v
    }
case "certified":
    if prop.BoolValue != nil {
        v := *prop.BoolValue
        result.Certified = &v
    }
case "provider":
    if prop.StringValue != nil {
        result.Provider = *prop.StringValue
    }
case "logo":
    if prop.StringValue != nil {
        result.Logo = *prop.StringValue
    }
case "category":
    if prop.StringValue != nil {
        result.Category = *prop.StringValue
    }
```

The Go struct in `models.go` mirrors these fields with appropriate types and JSON tags:

```go
type McpServer struct {
    // ... base fields ...
    DeploymentMode      string `json:"deploymentMode,omitempty"`
    Image               string `json:"image,omitempty"`
    Endpoint            string `json:"endpoint,omitempty"`
    SupportedTransports string `json:"supportedTransports,omitempty"`
    License             string `json:"license,omitempty"`
    Verified            *bool  `json:"verified,omitempty"`
    Certified           *bool  `json:"certified,omitempty"`
    Provider            string `json:"provider,omitempty"`
    Logo                string `json:"logo,omitempty"`
    Category            string `json:"category,omitempty"`
}
```

### Entity count bridge

The Loader ingests entities into the database with a `source_id` context property (set via `setEntitySourceID()` in `loader.go`). The Source Manager tracks source configurations but had no way to count entities per source.

```go
// mcpserver.go -- CountBySource implementation
func (r *McpServerRepositoryImpl) CountBySource(sourceID string) (int, error) {
    config := r.GetConfig()
    var count int64

    query := `SELECT COUNT(DISTINCT "Context".id) FROM "Context"
        INNER JOIN "ContextProperty" ON "Context".id="ContextProperty".context_id
            AND "ContextProperty".name='source_id'
            AND "ContextProperty".string_value=?
        WHERE "Context".type_id=?`
    if err := config.DB.Raw(query, sourceID, config.TypeID).Scan(&count).Error; err != nil {
        return 0, fmt.Errorf("error counting entities by source: %w", err)
    }
    return int(count), nil
}
```

This method follows the same SQL pattern already used in `DeleteBySource()` and `GetDistinctSourceIDs()`, joining the `Context` table (which stores entities) with the `ContextProperty` table (which stores the `source_id` property). The `type_id` filter ensures only McpServer entities are counted, not entities from other plugins sharing the same database.

The method is called from two places in `management.go`:

**ListSources:**
```go
if src.IsEnabled() {
    info.Status.State = plugin.SourceStateAvailable
    count, err := p.services.McpServerRepository.CountBySource(src.ID)
    if err == nil {
        info.Status.EntityCount = count
    }
}
```

**Diagnostics:**
```go
if src.IsEnabled() {
    count, err := p.services.McpServerRepository.CountBySource(src.ID)
    if err == nil {
        sd.EntityCount = count
    }
}
```

Both populate the `EntityCount` field defined in `pkg/catalog/plugin/management_types.go` as part of `SourceStatus` and `SourceDiagnostic` respectively.

### Before vs After

**API response -- before:**
```json
{
  "name": "kubernetes-mcp-server",
  "description": "MCP server for Kubernetes cluster management",
  "serverUrl": "quay.io/kubeflow/kubernetes-mcp-server:latest",
  "transportType": "stdio",
  "toolCount": 12,
  "resourceCount": 3
}
```

**API response -- after:**
```json
{
  "name": "kubernetes-mcp-server",
  "description": "MCP server for Kubernetes cluster management",
  "serverUrl": "quay.io/kubeflow/kubernetes-mcp-server:latest",
  "transportType": "stdio",
  "toolCount": 12,
  "resourceCount": 3,
  "promptCount": 2,
  "deploymentMode": "local",
  "image": "quay.io/kubeflow/kubernetes-mcp-server:latest",
  "endpoint": "",
  "supportedTransports": "stdio, http",
  "license": "Apache-2.0",
  "verified": true,
  "certified": true,
  "provider": "Red Hat",
  "logo": "",
  "category": "Red Hat"
}
```

**Sources response -- before:**
```json
{ "name": "MCP Servers", "status": { "state": "available", "entityCount": 0 } }
```

**Sources response -- after:**
```json
{ "name": "MCP Servers", "status": { "state": "available", "entityCount": 6 } }
```

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Fix all three layers (OpenAPI, model, converter) together | Partial fixes would leave API response incomplete or inconsistent; all three layers must agree on the set of fields | Fix only converter (OpenAPI spec would be inaccurate); fix only OpenAPI spec (fields would be null in responses) |
| SQL query with DISTINCT for CountBySource | Direct DB query is efficient; reuses existing GORM DB handle; DISTINCT prevents double-counting if entity has multiple source_id properties (defensive) | Load all entities and count in Go (wasteful for count-only operation); COUNT(*) without DISTINCT (risk of inflated counts) |
| Call CountBySource in both ListSources and Diagnostics | Both endpoints need entity counts for their consumers (UI sources table and diagnostics view) | Only ListSources (leaves diagnostics incomplete); only Diagnostics (UI sources table shows zeros) |
| Use `*bool` pointer type for verified/certified | Distinguishes between "not set" (nil, omitted from JSON) and "explicitly false", matching the OpenAPI boolean type with omitempty semantics | Use plain `bool` (would always serialize, even when not set; false would appear for servers with no verification data) |
| Error-tolerant count in ListSources | A count failure for one source should not prevent listing all sources; the count defaults to 0 if the query fails | Return error (blocks the entire ListSources call for a non-critical field) |

## Testing

### Unit tests

The existing `TestConvertToOpenAPIModel` and `TestConvertToOpenAPIModelMinimal` tests in `api_mcpserver_service_impl_test.go` validate the basic converter flow. The test sets up entity properties and verifies they are extracted correctly into the OpenAPI model. The minimal test confirms that missing properties result in zero-value fields rather than errors.

```bash
# Run converter tests
go test ./catalog/plugins/mcp/internal/server/openapi/... -v -count=1 -run TestConvertToOpenAPIModel
```

### Integration verification

```bash
# Verify extended fields in API response
curl -s http://localhost:8080/api/mcp_catalog/v1alpha1/mcpservers | python3 -c "
import sys, json
items = json.load(sys.stdin)['items']
for item in items:
    print(f\"{item['name']}: mode={item.get('deploymentMode','?')} provider={item.get('provider','?')} verified={item.get('verified','?')}\")
"
# kubernetes-mcp-server: mode=local provider=Red Hat verified=True
# openshift-mcp-server: mode=local provider=Red Hat verified=True
# ...

# Verify entity count in sources
curl -s http://localhost:8080/api/mcp_catalog/v1alpha1/sources | python3 -c "
import sys, json
for s in json.load(sys.stdin)['sources']:
    print(f\"{s['name']}: entityCount={s['status']['entityCount']}\")
"
# MCP Servers: entityCount=6

# Verify diagnostics also shows entity count
curl -s http://localhost:8080/api/catalog/v1alpha1/plugins/mcp/diagnostics | python3 -c "
import sys, json
diag = json.load(sys.stdin)
for s in diag['sources']:
    print(f\"{s['name']}: entityCount={s['entityCount']}\")
"
```

## Dependencies & Impact

- **Depends on**: M3.1 (real data loaded in database via YAML provider), M2.5 (management plane with ListSources/Diagnostics endpoints, McpServerRepository interface)
- **Enables**: M3.4 (UI gallery shows deployment badges, provider labels, category filters; sources table shows entity counts)
- The converter pattern (switch on property name) is consistent with the existing code generation approach where properties are stored as key-value pairs in ContextProperty and extracted during API serialization
- The CountBySource SQL pattern matches the existing DeleteBySource and GetDistinctSourceIDs patterns already in the repository

## Open Items

- Property extraction switch is handwritten; could be generated from `catalog.yaml` schema to ensure all defined properties are always handled
- No automated validation that OpenAPI spec, Go model, and converter are in sync (manual process; a generator or linter could catch drift)
- `CountBySource` executes a DB query per source in `ListSources`; for many sources, consider a batch counting query (e.g., `GROUP BY source_id` returning all counts in one query)
- The existing unit test (`TestConvertToOpenAPIModel`) does not yet cover the 10 new extended fields; adding test cases for boolean pointer fields (verified, certified) and string fields (deploymentMode, provider, category) would improve coverage
