# M3.2: BFF Real Wiring and API Alignment

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 3: Catalog Operationalization

## Files Modified

| File | Change |
|------|--------|
| `clients/ui/bff/internal/repositories/catalog_plugins.go` | Fixed `pluginsPath` from `"/plugins"` to `"/api/plugins"` to match catalog-server route structure |
| `clients/ui/bff/cmd/main.go` | BFF started in real mode with `CATALOG_SERVER_BASE_URL` environment variable; added fail-fast validation when URL is unset in real mode |
| `clients/ui/bff/internal/api/catalog_plugins_handler.go` | Verified handler calls real client in non-mock mode |
| `clients/ui/bff/internal/api/mcp_catalog_handler.go` | Verified handler calls real MCP catalog client |
| `clients/ui/bff/internal/api/catalog_management_handler.go` | Verified handler calls real management client |
| `clients/ui/bff/internal/repositories/mcp_catalog.go` | Verified real HTTP calls to catalog-server |
| `clients/ui/bff/internal/repositories/catalog_management.go` | Verified real HTTP calls to catalog-server |

## Summary

This milestone wired the BFF to proxy requests to the real catalog-server, removing mocks from the default code path. The primary bug discovered was an API path mismatch: the BFF used `/plugins` but the catalog-server serves at `/api/plugins`. The BFF's HTTP client concatenates `baseURL + path`, so the path constant must match the server's route structure exactly.

Additionally, the BFF's `main.go` was hardened with a fail-fast check: if `--mock-mr-catalog-client` is not set and `CATALOG_SERVER_BASE_URL` is empty, the process exits immediately with a clear error message rather than silently failing per-request.

## How It Works

### Request flow (real mode)

```
Frontend (localhost:9000) --> BFF (localhost:4000) --> Catalog Server (localhost:8080)
```

### BFF startup in real mode

```bash
cd clients/ui/bff && CATALOG_SERVER_BASE_URL=http://localhost:8080 go run ./cmd/ \
  --port=4000 \
  --mock-k8s-client=true \
  --dev-mode=true \
  --deployment-mode=standalone
```

The BFF's `AttachModelCatalogRESTClient` middleware creates an HTTP client using `CATALOG_SERVER_BASE_URL` as the base URL. Repository methods then make `GET`/`POST`/`DELETE` calls to paths like `/api/plugins`, `/api/mcp_catalog/v1alpha1/mcpservers`, etc.

### The path fix

```go
// Before (broken):
const pluginsPath = "/plugins"
// After (fixed):
const pluginsPath = "/api/plugins"
```

The catalog-server mounts all plugin routes under `/api/`. The BFF HTTP client does simple string concatenation: `baseURL + path`. Without the `/api/` prefix, the BFF was hitting `http://localhost:8080/plugins` which returned 404.

This constant is used in two places:
1. `CatalogPlugins.GetAllCatalogPlugins()` -- direct plugin listing
2. `CatalogManagement.ResolvePluginBasePath()` -- fetches the plugin list to resolve a plugin name to its `basePath` before making management API calls

### The fail-fast check

```go
// clients/ui/bff/cmd/main.go
if !cfg.MockMRCatalogClient && cfg.CatalogServerURL == "" {
    logger.Error("CATALOG_SERVER_BASE_URL is required in real mode; use --mock-mr-catalog-client for dev mode")
    os.Exit(1)
}
```

This prevents the BFF from starting in a broken state where every catalog request would fail with a connection error.

### BFF routes to catalog-server routes mapping

All catalog management handlers use `ResolvePluginBasePath()` to dynamically discover each plugin's `basePath` from the `/api/plugins` response. This means the BFF does not hardcode plugin-specific paths -- it resolves them at runtime.

| BFF Route | Handler | Catalog Server Path (resolved) |
|-----------|---------|-------------------------------|
| `GET /api/v1/catalog/plugins` | `GetAllCatalogPluginsHandler` | `GET /api/plugins` |
| `GET /api/v1/catalog/:plugin/sources` | `GetPluginSourcesHandler` | `GET /api/:plugin_name/v1alpha1/sources` |
| `POST /api/v1/catalog/:plugin/validate-source` | `ValidatePluginSourceConfigHandler` | `POST /api/:plugin_name/v1alpha1/validate-source` |
| `POST /api/v1/catalog/:plugin/apply-source` | `ApplyPluginSourceConfigHandler` | `POST /api/:plugin_name/v1alpha1/apply-source` |
| `POST /api/v1/catalog/:plugin/sources/:id/enable` | `EnablePluginSourceHandler` | `POST /api/:plugin_name/v1alpha1/sources/:id/enable` |
| `DELETE /api/v1/catalog/:plugin/sources/:id` | `DeletePluginSourceHandler` | `DELETE /api/:plugin_name/v1alpha1/sources/:id` |
| `POST /api/v1/catalog/:plugin/refresh` | `RefreshPluginHandler` | `POST /api/:plugin_name/v1alpha1/refresh` |
| `POST /api/v1/catalog/:plugin/refresh/:id` | `RefreshPluginSourceHandler` | `POST /api/:plugin_name/v1alpha1/refresh/:id` |
| `GET /api/v1/catalog/:plugin/diagnostics` | `GetPluginDiagnosticsHandler` | `GET /api/:plugin_name/v1alpha1/diagnostics` |
| `GET /api/v1/mcp_catalog/mcpservers` | `GetMcpServersHandler` | `GET /api/mcp_catalog/v1alpha1/mcpservers` |
| `GET /api/v1/mcp_catalog/mcpservers/:name` | `GetMcpServerHandler` | `GET /api/mcp_catalog/v1alpha1/mcpservers/:name` |

### Repository layer design

The real repository implementations follow a consistent pattern:

1. **`catalog_plugins.go`** uses a fixed path constant (`/api/plugins`) for the top-level plugin listing.
2. **`catalog_management.go`** resolves plugin base paths dynamically via `ResolvePluginBasePath()`, then appends management sub-paths (`/sources`, `/refresh`, `/diagnostics`, `/validate-source`, `/apply-source`).
3. **`mcp_catalog.go`** receives the resolved base path from the handler and appends entity paths (`/mcpservers`, `/mcpservers/:name`).

All three use `url.JoinPath()` for safe path construction (handling trailing slashes correctly) and follow the same error handling pattern: marshal/unmarshal JSON, wrap errors with context, and propagate `HTTPError` types for proper status code forwarding.

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Fix path constant, not middleware | The path must match the server's actual route structure; middleware rewriting adds complexity and is fragile to debug | URL rewriting middleware (fragile, hard to debug) |
| Keep mock flag for development | Developers without a running catalog-server still need to work on the UI; `--mock-mr-catalog-client=true` enables this | Remove mocks entirely (blocks frontend development without full stack) |
| Fail-fast on missing URL | A BFF that starts but cannot reach the catalog-server causes confusing per-request errors; early exit with a clear message is better | Lazy validation on first request (delays error discovery) |
| Verify all repository paths | Proactively checked all HTTP call paths in real repositories to prevent similar 404s | Fix only the reported path (risk of discovering more mismatches later) |
| Dynamic base path resolution | `ResolvePluginBasePath()` fetches `/api/plugins` and looks up the plugin's `basePath` at runtime, so the BFF does not hardcode plugin route prefixes | Hardcoded path mapping per plugin (brittle, breaks when plugins are added or renamed) |

## Verification

```bash
# Start catalog-server (Docker Compose or direct)
docker compose -f docker-compose.catalog.yaml up -d

# Start BFF in real mode
cd clients/ui/bff && CATALOG_SERVER_BASE_URL=http://localhost:8080 go run ./cmd/ \
  --port=4000 --mock-k8s-client=true --dev-mode=true --deployment-mode=standalone

# Verify plugins endpoint returns real data
curl -s "http://localhost:4000/api/v1/catalog/plugins?namespace=default" | python3 -m json.tool

# Verify plugin sources
curl -s "http://localhost:4000/api/v1/catalog/mcp/sources?namespace=default" | python3 -m json.tool

# Verify MCP servers
curl -s "http://localhost:4000/api/v1/mcp_catalog/mcpservers?namespace=default" | python3 -m json.tool

# Verify real data (not mock) -- expect count from catalog-server's loaded YAML
curl -s "http://localhost:4000/api/v1/mcp_catalog/mcpservers?namespace=default" | \
  python3 -c "import sys,json; d=json.load(sys.stdin); print('count:', d['data']['size'])"
# Output: count: 6

# Verify fail-fast: BFF refuses to start without CATALOG_SERVER_BASE_URL
cd clients/ui/bff && go run ./cmd/ --port=4000 --mock-k8s-client=true --dev-mode=true --deployment-mode=standalone
# Expected: exits with "CATALOG_SERVER_BASE_URL is required in real mode"

# Verify mock mode still works
cd clients/ui/bff && go run ./cmd/ --port=4000 --mock-k8s-client=true --mock-mr-catalog-client=true \
  --dev-mode=true --deployment-mode=standalone
# Expected: starts successfully, returns mock data
```

## Dependencies & Impact

- **Depends on**: M3.1 (Docker infrastructure running catalog-server)
- **Enables**: M3.4 (UI pages consume real data through BFF)
- **Backward compatible**: mock mode still available via `--mock-mr-catalog-client=true` flag
- **No breaking changes**: all existing BFF routes, handlers, and mock behavior remain intact

## Open Items

- No health check from BFF to catalog-server at startup -- the fail-fast check validates configuration only, not connectivity
- Response shape verification: BFF passes through JSON as-is; no schema validation between BFF and catalog-server
- `ResolvePluginBasePath()` makes a full `/api/plugins` call for every management request; caching the plugin list would reduce round-trips
