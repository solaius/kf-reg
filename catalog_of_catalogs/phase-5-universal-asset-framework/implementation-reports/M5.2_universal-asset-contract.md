# M5.2: Universal Asset Contract

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 5 - Universal Asset Framework

## Overview

Defined the `AssetResource` envelope type and `AssetMapper` interface that enable plugins to project their native entities into a uniform shape for cross-plugin rendering. This is a pure contract milestone: it establishes the types, interfaces, and helpers that subsequent milestones use to implement generic listing, detail views, and cross-plugin search.

## Goal

Create a universal entity projection system where any plugin entity (MCP server, model, dataset, knowledge source, etc.) can be represented as a single `AssetResource` type without modifying the plugin's native API responses. This enables generic UI components and CLI commands to render entities from any plugin without plugin-specific code.

## Files Created

| File | Purpose |
|------|---------|
| `pkg/catalog/plugin/asset_types.go` | Defines the universal envelope types: `AssetResource`, `AssetMetadata`, `AssetOwner`, `SourceRef`, `AssetStatus`, `LifecycleStatus` (4 constants), `HealthStatus` (4 constants), `StatusCondition`, `AssetLinks`, `LinkRef`, `AssetList` |
| `pkg/catalog/plugin/asset_mapper.go` | Defines the `AssetMapper` interface (`MapToAsset`, `MapToAssets`, `SupportedKinds`), `AssetMapperProvider` interface, `AssetLister` interface, `AssetGetter` interface, `AssetListOptions` struct, `MapToAssetsBatch()` helper, and `DefaultAssetStatus()` factory |
| `pkg/catalog/plugin/asset_mapper_test.go` | Comprehensive test suite with 11 test functions/subtests covering status defaults, lifecycle/health constant values, JSON round-trips (minimal, fully populated, nil-optional), mock mapper correctness, error handling, batch mapping, provider interface satisfaction, `AssetList` serialization, and `AssetListOptions` serialization |

## Files Modified

| File | Change |
|------|--------|
| `pkg/catalog/plugin/plugin.go` | Added comment reference noting that `AssetMapperProvider` is defined in `asset_mapper.go`. The interface is available to all plugins via the `plugin` package. |

## Type System

### AssetResource Envelope

The `AssetResource` struct follows a Kubernetes-inspired structure with four top-level fields:

```go
type AssetResource struct {
    APIVersion string         `json:"apiVersion"` // e.g. "catalog/v1alpha1"
    Kind       string         `json:"kind"`       // e.g. "McpServer", "CatalogModel"
    Metadata   AssetMetadata  `json:"metadata"`
    Spec       map[string]any `json:"spec"`
    Status     AssetStatus    `json:"status"`
}
```

- `APIVersion` + `Kind` provide type discrimination for multi-kind lists
- `Metadata` carries identity, discovery labels/tags, ownership, and source provenance
- `Spec` is an unstructured map holding entity-specific fields (no schema enforcement at the envelope level)
- `Status` tracks lifecycle phase, health, Kubernetes-style conditions, and cross-asset links

### AssetMetadata

| Field | Type | Purpose |
|-------|------|---------|
| `UID` | `string` | Unique identifier across the catalog |
| `Name` | `string` | Human-readable name, unique within a source |
| `DisplayName` | `string` | Optional prettier display name |
| `Description` | `string` | Optional description |
| `Labels` | `map[string]string` | Key-value labels for filtering |
| `Annotations` | `map[string]string` | Key-value annotations for metadata |
| `Tags` | `[]string` | Freeform tags |
| `CreatedAt` | `string` | ISO 8601 creation timestamp |
| `UpdatedAt` | `string` | ISO 8601 last-update timestamp |
| `Owner` | `*AssetOwner` | Optional owner (name, email, team) |
| `SourceRef` | `*SourceRef` | Links back to the catalog source that ingested this asset |

### Status Model

The status model uses typed string enums for lifecycle and health:

| Type | Constants |
|------|-----------|
| `LifecycleStatus` | `active`, `deprecated`, `retired`, `draft` |
| `HealthStatus` | `unknown`, `healthy`, `degraded`, `unhealthy` |

`StatusCondition` follows the Kubernetes `type/status/reason/message` pattern for extensible condition reporting.

`AssetLinks` holds a `Related` slice of `LinkRef` entries for cross-asset references (e.g., a model linking to its artifact, a server linking to its tools).

### AssetList

Paginated list envelope matching the project's standard pagination contract:

```go
type AssetList struct {
    APIVersion    string          `json:"apiVersion"`
    Kind          string          `json:"kind"` // always "AssetList"
    Items         []AssetResource `json:"items"`
    NextPageToken string          `json:"nextPageToken,omitempty"`
    TotalSize     int             `json:"totalSize,omitempty"`
}
```

## Interfaces

### AssetMapper

The core projection interface that plugin mappers implement:

```go
type AssetMapper interface {
    MapToAsset(entity any) (AssetResource, error)
    MapToAssets(entities []any) ([]AssetResource, error)
    SupportedKinds() []string
}
```

- `MapToAsset`: Converts a single plugin-native entity (e.g., `*openapi.McpServer`) into an `AssetResource`
- `MapToAssets`: Batch variant for list operations
- `SupportedKinds`: Declares which entity kinds this mapper handles

### AssetMapperProvider

Optional plugin interface for providing a mapper instance:

```go
type AssetMapperProvider interface {
    GetAssetMapper() AssetMapper
}
```

### AssetLister and AssetGetter

Optional interfaces for plugins that want to support the unified `/api/assets` endpoint directly:

```go
type AssetLister interface {
    ListAssets(ctx context.Context, opts AssetListOptions) (*AssetList, error)
}

type AssetGetter interface {
    GetAsset(ctx context.Context, kind string, name string) (*AssetResource, error)
}
```

### Helpers

| Helper | Purpose |
|--------|---------|
| `MapToAssetsBatch(entities, mapFn)` | Generic loop+error-handling for batch mapping. Plugin mappers delegate `MapToAssets` to this. |
| `DefaultAssetStatus()` | Returns `AssetStatus{Lifecycle: "active", Health: "unknown"}` as the standard starting status. |

## Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| Additive projection, not replacement | Plugin-specific API responses (`/api/mcp_catalog/v1alpha1/mcpservers`) remain unchanged. `AssetMapper` projects into `AssetResource` as a separate layer. Zero breaking changes to existing consumers. |
| `Spec` as `map[string]any` | Avoids requiring all plugins to share a single typed schema. Each plugin flattens its entity-specific fields into the map. Generic UI reads field paths from V2 capabilities. |
| Kubernetes-style status model | Familiar pattern for cloud-native users. `Conditions` array allows plugins to report multiple orthogonal states (e.g., "Ready", "Synced", "Validated") without a single-enum bottleneck. |
| `AssetMapper` takes `any` parameter | Plugins pass their concrete entity types. The mapper performs type assertion internally. This avoids import cycles and keeps the plugin package free of plugin-specific type dependencies. |
| Separate `AssetLister`/`AssetGetter` interfaces | Not every plugin needs to support unified listing immediately. These are opt-in interfaces that the unified assets endpoint checks for via type assertion. |
| `SourceRef` in metadata | Every asset tracks which source it came from. This enables source-scoped filtering and allows the UI to show provenance information. |

## Test Results

All tests pass across 11 test functions and subtests:

| Test | Coverage |
|------|----------|
| `TestDefaultAssetStatus` | Verifies default returns `active` lifecycle, `unknown` health, nil conditions, nil links |
| `TestLifecycleStatusValues` | Table-driven: all 4 lifecycle constants match expected string values |
| `TestHealthStatusValues` | Table-driven: all 4 health constants match expected string values |
| `TestAssetResourceJSONRoundTrip` | 3 subtests: minimal asset, fully populated asset (owner, source ref, tags, labels, annotations, conditions, links), asset with nil optional fields |
| `TestAssetMapperMock` | 5 subtests: correct envelope production, error on invalid input, multi-entity batch mapping, error propagation in batch, supported kinds |
| `TestMapToAssetsBatch` | 3 subtests: empty slice, successful batch, error propagation |
| `TestAssetMapperProviderInterface` | Verifies provider interface satisfaction and mapper retrieval |
| `TestAssetListJSONRoundTrip` | Full `AssetList` with 2 items, pagination token, and total size round-trips correctly |
| `TestAssetListOptionsJSONRoundTrip` | `AssetListOptions` with all fields populated round-trips correctly |

Compile-time interface assertions verify:
- `testAssetMapper` satisfies `AssetMapper`
- `testMapperProvider` satisfies `AssetMapperProvider`

```
go test ./pkg/catalog/plugin/... -v -run "TestDefaultAssetStatus|TestLifecycleStatus|TestHealthStatus|TestAssetResource|TestAssetMapper|TestMapToAssetsBatch|TestAssetList" -count=1
```

## Acceptance Criteria

| # | Criterion | Status |
|---|-----------|--------|
| AC1 | `AssetResource` envelope type defined with apiVersion, kind, metadata, spec, and status | Met |
| AC2 | `AssetMapper` interface defined with `MapToAsset`, `MapToAssets`, and `SupportedKinds` | Met |
| AC3 | JSON round-trip tests pass for all envelope types including edge cases (nil optionals, fully populated) | Met |
| AC4 | Zero breaking changes to existing plugin API responses and interfaces | Met |

## Dependencies and Impact

- **Enables**: M5.3 (MCP plugin implements `AssetMapperProvider` to project `McpServer` into `AssetResource`), M5.5 (unified `/api/assets` endpoint aggregates across plugins using `AssetLister`), generic UI components that render any `AssetResource` without plugin-specific templates
- **Depends on**: Phase 1 plugin framework (`CatalogPlugin` interface in `pkg/catalog/plugin/plugin.go`)
- **Backward compatible**: Fully additive. No existing interfaces, types, or API responses were modified. Existing plugins continue to work without implementing any of the new interfaces.
