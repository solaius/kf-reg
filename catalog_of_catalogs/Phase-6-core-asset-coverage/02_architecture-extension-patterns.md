# Architecture and extension patterns for Phase 6

## Design principles
- Everything is a plugin
  - Each asset type is a catalog plugin with its own API paths, tables, providers, and schema, but must conform to the universal asset contract and action model
- UI and CLI are generated by capability discovery
  - No per-plugin frontend pages or CLI subcommands should be required for standard list/get/actions flows
- Schema-first and deterministic generation
  - catalog.yaml remains the authoritative schema definition for catalog-gen generated plugins
  - Generated code is deterministic and separated into editable vs non-editable files
- Provider reuse
  - Providers (YAML, HTTP, Git, OCI) should be shared building blocks that multiple plugins can consume
- Safe operations
  - Validation, apply, rollback, and audit metadata are first-class for anything that mutates state

## Assumed baseline (from Phase 5)
- Capabilities endpoint exists and is authoritative for UI and CLI rendering
- Universal asset contract exists for shared fields and lifecycle metadata
- Universal action model exists for consistent management verbs, with plugin opt-in
- Conformance suite exists, and plugins must pass it

## Phase 6 architectural additions
### 1) Shared provider contracts
Define standard provider interfaces and shared implementations:
- Provider identity and version
- Source configuration schema
- Fetch semantics (full sync vs incremental, pagination, rate limits)
- Artifact retrieval semantics (inline vs references)
- Error taxonomy and retry semantics

### 2) Strong schema governance and compatibility
- Every plugin schema must define:
  - Required fields
  - Optional fields with clear semantics and defaults
  - Validation constraints (types, allowed values, patterns)
  - Backward compatibility rules for schema evolution
- Universal fields (labels, annotations, lifecycle state, capabilities) must be consistent across all plugins

### 3) Cross-asset linking model
Agents and other assets must reference other assets consistently:
- Reference type is always explicit:
  - plugin type
  - source id (optional if global)
  - asset id (stable identifier)
  - version or digest (optional but recommended)
- References must be resolvable via standard list/get APIs

### 4) "Asset as artifact" representation
For artifacts stored outside the DB (OCI, Git, object storage):
- DB stores metadata, pointers, digests
- Provider is responsible for fetching and verifying artifacts
- Validation should include digest verification and schema validation

## Required updates to existing plugins
### Model plugin
- Confirm it aligns to the universal asset contract
- Add or normalize fields for:
  - licensing
  - provenance
  - supported modalities and tasks
  - artifact references and digests (where available)
- Ensure capabilities reflect what the plugin truly supports

### MCP plugin
- Confirm it aligns to the universal asset contract
- Normalize tool and endpoint metadata, and JSON Schema usage for tool input/output schemas
- Ensure container image and remote endpoint fields are first-class
- Ensure local vs remote MCP server classification is explicit

### Knowledge Sources plugin
- Confirm it aligns to the universal asset contract
- Ensure it can represent:
  - file-based sources
  - web sources
  - database sources (vector, graph, sql)
  - SaaS connectors (if desired, even if not executed in Phase 6)
- Ensure linkability from Agents

## Definition of done
- Documented extension pattern for adding a new plugin in Phase 6
- Documented pattern for linking assets across plugins
- Documented schema evolution rules and how to regenerate safely
- Model, MCP, and Knowledge Sources alignment work is planned and testable
