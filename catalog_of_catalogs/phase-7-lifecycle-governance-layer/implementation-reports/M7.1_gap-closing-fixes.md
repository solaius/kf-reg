# M7.1: Phase 7 Gap-Closing Fixes

**Date**: 2026-02-17
**Status**: Complete
**Phase**: Phase 7 - Lifecycle Governance Layer

## Summary
Closes 5 gaps identified in Phase 7 code review: (1) signature verification in provenance, (2) audit retention cleanup job, (3) ProvenancePanel UI wiring, (4) multi-plugin conformance test coverage, and (5) conformance hard proof run with test stability fixes.

## Motivation
- Code review identified that `applyProvenance()` populated source fields but not integrity fields, despite DB columns existing
- `AuditRetentionConfig` (90-day default) existed but no cleanup job ran
- `ProvenancePanel` component existed but wasn't wired into the detail page
- All governance conformance tests hardcoded `plugin="mcp"`, missing proof that governance works cross-plugin
- No clean conformance proof run captured against live stack

## What Changed

### Files Modified

| File | Change |
|------|--------|
| `pkg/catalog/governance/provenance.go` | Added `VerifyingProvenanceExtractor` decorator; extended `applyProvenance()` to write integrity fields |
| `pkg/catalog/governance/provenance_test.go` | Added 6 tests: integrity in `applyProvenance`, verifying extractor success/error/nil, interface coverage |
| `pkg/catalog/governance/audit.go` | Added `DeleteOlderThan(cutoff time.Time) (int64, error)` method |
| `pkg/catalog/governance/audit_test.go` | Added 2 tests: delete older events, no-match case |
| `pkg/catalog/plugin/server.go` | Added `AuditCleanupLoop(ctx context.Context)` background goroutine |
| `cmd/catalog-server/main.go` | Launched `go server.AuditCleanupLoop(ctx)` alongside ReconcileLoop |
| `clients/ui/frontend/.../ProvenancePanel.tsx` | Rewrote to be self-fetching (accepts plugin/kind/name, fetches versions API) |
| `clients/ui/frontend/.../PluginEntityDetailPage.tsx` | Added ProvenancePanel rendering after VersionsPanel |
| `tests/conformance/governance_helpers_test.go` | Added `governanceTestPlugin` type, `governanceTestPlugins()`, `ensureGovernanceAtState()` with auto-approval, per-run name prefix |
| `tests/conformance/governance_test.go` | Wrapped `TestGovernanceCRUD` in multi-plugin loop |
| `tests/conformance/lifecycle_test.go` | Wrapped in plugin loop; replaced local `ensureAtState` with shared `ensureGovernanceAtState` |
| `tests/conformance/promotion_test.go` | Wrapped in plugin loop; replaced inline state walking with `ensureGovernanceAtState` |
| `tests/conformance/audit_test.go` | Wrapped `TestGovernanceAudit` in multi-plugin loop |
| `tests/conformance/provenance_test.go` | Wrapped `TestGovernanceProvenance` in multi-plugin loop |
| `tests/conformance/approvals_test.go` | Wrapped `TestGovernanceApprovals` in multi-plugin loop |
| `tests/conformance/governance_e2e_test.go` | Wrapped `TestGovernanceE2EFullLifecycle` in multi-plugin loop |

## How It Works

### Gap 1: Signature Verification

The `VerifyingProvenanceExtractor` wraps any `ProvenanceExtractor` and adds integrity verification:

```go
type VerifyingProvenanceExtractor struct {
    Inner       ProvenanceExtractor
    Method      string // e.g., "sha256-content-hash"
    ComputeHash func(plugin, kind, name string) (string, error)
}

func (e *VerifyingProvenanceExtractor) ExtractProvenance(plugin, kind, name string) *ProvenanceInfo {
    prov := e.Inner.ExtractProvenance(plugin, kind, name)
    if prov == nil { return nil }
    hash, err := e.ComputeHash(plugin, kind, name)
    if err != nil {
        prov.Integrity = &IntegrityInfo{Verified: false, Method: e.Method, Details: err.Error()}
    } else {
        prov.Integrity = &IntegrityInfo{Verified: true, Method: e.Method, Details: hash}
    }
    return prov
}
```

`applyProvenance()` now writes integrity fields to the DB record:

```go
func applyProvenance(record *AssetVersionRecord, prov *ProvenanceInfo) {
    // ... existing source fields ...
    if prov.Integrity != nil {
        record.ProvenanceVerified = prov.Integrity.Verified
        record.ProvenanceMethod = prov.Integrity.Method
        record.ProvenanceDetails = prov.Integrity.Details
    }
}
```

### Gap 2: Audit Retention Cleanup

```go
// AuditStore method
func (s *AuditStore) DeleteOlderThan(cutoff time.Time) (int64, error) {
    result := s.db.Where("created_at < ?", cutoff).Delete(&AuditEventRecord{})
    return result.RowsAffected, result.Error
}

// Server background loop (follows ReconcileLoop pattern)
func (s *Server) AuditCleanupLoop(ctx context.Context) {
    ticker := time.NewTicker(24 * time.Hour)
    defer ticker.Stop()
    for {
        select {
        case <-ctx.Done(): return
        case <-ticker.C:
            cutoff := time.Now().AddDate(0, 0, -s.governanceConfig.AuditRetention.Days)
            deleted, _ := s.auditStore.DeleteOlderThan(cutoff)
            if deleted > 0 { s.logger.Info("audit cleanup completed", "deleted", deleted) }
        }
    }
}
```

### Gap 3: ProvenancePanel UI Wiring

Rewrote `ProvenancePanel.tsx` to be self-fetching — it takes `plugin`, `kind`, `name` props and fetches the versions API to extract provenance from the latest version. Added to `PluginEntityDetailPage.tsx` after VersionsPanel, gated by `governanceSupported && versioning.enabled`.

### Gap 4: Multi-Plugin Conformance

All 7 governance conformance test files now iterate over `governanceTestPlugins()`:

```go
func governanceTestPlugins() []governanceTestPlugin {
    return []governanceTestPlugin{
        {Plugin: "mcp", Kind: "mcpserver"},
        {Plugin: "agents", Kind: "Agent"},
    }
}
```

### Gap 5: Test Stability Fixes

Three issues discovered and fixed during the conformance proof run:

1. **Verdict format**: Changed `"verdict": "approved"` → `"verdict": "approve"` to match server validation
2. **Self-approval guard**: Used separate `X-User-Principal: conformance-auto-approver` header for approval decisions (server prevents requester from approving their own request)
3. **Name collisions**: Changed `testSeqNum()` from returning `int64` to `string` with a per-run timestamp prefix (`{millis%100000}-{seq}`) to prevent DB name collisions across test runs

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Decorator pattern for `VerifyingProvenanceExtractor` | Composes with any extractor; doesn't modify existing extractors | Modifying each extractor directly (less composable) |
| Daily audit cleanup ticker | Follows `ReconcileLoop` pattern already in codebase; low overhead | Event-driven cleanup (more complex, same outcome) |
| Self-fetching ProvenancePanel | Panel can be placed anywhere without parent providing data | Props-based (requires parent to manage fetch lifecycle) |
| Per-run name prefix in `testSeqNum()` | Eliminates DB state pollution across test runs | Truncating DB tables (destructive, may affect parallel runs) |
| Separate approver principal | Required by server's self-approval guard | Disabling self-approval check (weakens governance security) |

## Testing

### Unit Tests
```bash
go test ./pkg/catalog/governance/... -v -count=1    # All pass (includes provenance + audit additions)
```

### Conformance Tests (against live stack)
```bash
CATALOG_SERVER_URL=http://localhost:8080 go test ./tests/conformance/... -v -count=1 -run "TestGovernance"
```

**Results**: All 7 governance test suites pass across both `mcp` and `agents` plugins:
- `TestGovernanceApprovals` — PASS (mcp + agents)
- `TestGovernancePolicies` — PASS
- `TestGovernanceAudit` — PASS (mcp + agents, 10 subtests)
- `TestGovernanceE2EFullLifecycle` — PASS (mcp + agents)
- `TestGovernanceCRUD` — PASS (mcp + agents, 8 subtests)
- `TestGovernanceLifecycle` — PASS (mcp + agents, 18 subtests)
- `TestGovernancePromotion` — PASS (mcp + agents, 18 subtests)
- `TestGovernanceProvenance` — PASS (mcp + agents, 6 subtests)

### Backward Compatibility
All backward-compatibility and infrastructure tests pass:
- `TestBackwardCompatModelCatalog` — PASS (8 plugin endpoints)
- `TestBackwardCompatPluginList` — PASS (8 plugins)
- `TestBackwardCompatCapabilitiesIncludeGovernance` — PASS (8 plugins)
- `TestBackwardCompatHealthEndpoints` — PASS (/healthz, /livez, /readyz)
- `TestPagination` — PASS (8 plugins)

### Pre-existing Failures (not in scope)
`TestConformance` action tests (tag/annotate/deprecate) fail across all plugins — this is a pre-existing Phase 5 issue with the entity action endpoint format, unrelated to governance.

## Verification

```bash
# Unit tests
go test ./pkg/catalog/governance/... -v -count=1

# Start fresh stack
docker compose -f docker-compose.catalog.yaml down -v
docker compose -f docker-compose.catalog.yaml up --build -d
curl -s http://localhost:8080/readyz

# Full governance conformance (both mcp + agents)
CATALOG_SERVER_URL=http://localhost:8080 go test ./tests/conformance/... -v -count=1 -run "TestGovernance"

# Full suite excluding pre-existing action failures
CATALOG_SERVER_URL=http://localhost:8080 go test ./tests/conformance/... -v -count=1 -run "TestGovernance|TestBackwardCompat|TestCapabilities|TestPluginNames|TestBasePaths|TestPagination"
```

## Dependencies & Impact
- Completes Phase 7 governance layer
- No new dependencies introduced
- Backward compatible with all existing catalog functionality
- Enables idempotent conformance test runs (no DB state pollution)

## Open Items
- `TestConformance` action tests (tag/annotate/deprecate) are pre-existing Phase 5 failures — entity action endpoint format may need updating in a future phase
- The `high-risk-approval` policy's `requiredCount: 2` means E2E tests requiring full approval for high-risk assets need 2 separate approver identities
