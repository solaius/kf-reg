# M4.3: Apply-to-Refresh Feedback Loop

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 4 - Catalog Management Productionization

## Summary

Added a `refreshAfterApply` option to the source apply flow that triggers an immediate refresh after saving configuration changes. The apply response now includes refresh results (entity counts, duration, errors) so the UI can display immediate feedback. Extended `SourceStatus` with last refresh metadata fields for ongoing visibility.

## Motivation

- After saving a source configuration in Phase 3, there was no immediate feedback on whether the new config would load entities correctly. Users had to manually trigger a refresh and then check diagnostics separately.
- The UI couldn't display entity counts after a save because the response only contained `{"status": "applied"}`.
- Source status lacked historical refresh metadata, making it hard to tell when a source was last refreshed or whether it succeeded.

## What Changed

### Files Modified

| File | Change |
|------|--------|
| `pkg/catalog/plugin/management_types.go` | Added `RefreshAfterApply` to `SourceConfigInput`, new `ApplyResult` type, extended `SourceStatus` |
| `pkg/catalog/plugin/management_handlers.go` | Enhanced `applyHandler` to trigger refresh and return `ApplyResult` with `RefreshResult` |
| `pkg/catalog/plugin/management_handlers_test.go` | Added tests for apply-with-refresh and apply-without-refresh |

## How It Works

### RefreshAfterApply Option

A new optional boolean field on `SourceConfigInput` signals the server to refresh after applying:

```go
type SourceConfigInput struct {
    // ... existing fields ...
    RefreshAfterApply *bool `json:"refreshAfterApply,omitempty"`
}
```

### ApplyResult Response

The apply endpoint now returns a structured `ApplyResult` instead of a plain map:

```go
type ApplyResult struct {
    Status        string         `json:"status"`
    RefreshResult *RefreshResult `json:"refreshResult,omitempty"`
}
```

When `refreshAfterApply` is true and the plugin implements `RefreshProvider`, the handler calls `Refresh(sourceID)` and populates the result:

```go
if input.RefreshAfterApply != nil && *input.RefreshAfterApply {
    if rp, ok := p.(RefreshProvider); ok {
        start := time.Now()
        refreshResult, err := rp.Refresh(r.Context(), input.ID)
        elapsed := time.Since(start)
        if err != nil {
            result.RefreshResult = &RefreshResult{
                SourceID: input.ID,
                Duration: elapsed,
                Error:    err.Error(),
            }
        } else if refreshResult != nil {
            refreshResult.Duration = elapsed
            result.RefreshResult = refreshResult
        }
    }
}
```

### Extended SourceStatus

Two new fields provide ongoing visibility into refresh state:

```go
type SourceStatus struct {
    // ... existing State, EntityCount, Error ...
    LastRefreshTime    *time.Time `json:"lastRefreshTime,omitempty"`
    LastRefreshStatus  string     `json:"lastRefreshStatus,omitempty"`
    LastRefreshSummary string     `json:"lastRefreshSummary,omitempty"`
}
```

### Handler Signature Change

The `applyHandler` function signature was extended to include the plugin reference (needed to check for `RefreshProvider` interface):

```go
func applyHandler(sm SourceManager, srv *Server, configKey string, p CatalogPlugin) http.HandlerFunc
```

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Synchronous refresh in apply response | Simple, immediate feedback; typical refresh < 2s | Async refresh with polling/webhooks |
| Optional via `refreshAfterApply` flag | Backward compatible; callers that don't send it get the old behavior | Always refresh (may slow down bulk operations) |
| Include duration in RefreshResult | Helps UI show performance feedback and detect slow sources | Omit timing, let UI track it client-side |

## Testing

Tests in `management_handlers_test.go`:
- `TestApplyHandler_WithRefreshAfterApply` - Verifies refresh is triggered and result included
- `TestApplyHandler_WithoutRefreshAfterApply` - Verifies no refresh when flag is absent/false

E2E tests in `tests/e2e/catalog_phase4_smoke_test.go`:
- `TestPhase4ApplyWithRefreshAfterApply` - Full round-trip with live server
- `TestPhase4ApplyWithoutRefreshAfterApply` - Verifies omission

```bash
go test ./pkg/catalog/plugin/... -v -run "TestApply" -count=1
```

## Verification

```bash
# With Docker stack running:
# Apply with refresh
curl -s -X POST http://localhost:8080/api/mcp_catalog/v1alpha1/apply-source \
  -H 'Content-Type: application/json' \
  -d '{
    "id": "mcp-default",
    "name": "MCP Servers",
    "type": "yaml",
    "enabled": true,
    "refreshAfterApply": true,
    "properties": {"yamlCatalogPath": "/plugins/mcp/data/mcp-servers.yaml"}
  }' | jq '.refreshResult'

# Apply without refresh (should have no refreshResult)
curl -s -X POST http://localhost:8080/api/mcp_catalog/v1alpha1/apply-source \
  -H 'Content-Type: application/json' \
  -d '{
    "id": "mcp-default",
    "name": "MCP Servers",
    "type": "yaml",
    "properties": {"yamlCatalogPath": "/plugins/mcp/data/mcp-servers.yaml"}
  }' | jq 'has("refreshResult")'
```

## Dependencies & Impact

- **Enables**: Frontend can show toast with entity counts after save; sources page can display last refresh time
- **Depends on**: M4.2 (apply handler pre-validation runs before refresh), RefreshProvider interface (Phase 3)
- **Backward compatible**: Existing apply calls without `refreshAfterApply` continue to work unchanged; response structure is a superset

## Open Items

- Synchronous refresh blocks the HTTP response; for very large sources (> 30s), consider adding a timeout or async option
- `LastRefreshStatus` and `LastRefreshSummary` fields are defined but not yet populated by the MCP plugin's `ListSources()` (deferred to MCP plugin enhancement)
