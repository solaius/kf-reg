# M4.6: Phase 4 Review Fixes

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 4 - Catalog Management Productionization

## Summary

Addressed all review findings on the Phase 4 spec pack across three rounds. Round 1 established the foundational fixes: strict plugin content validation, DB-persisted refresh status, SecretRef type with redaction/warnings, and spec doc updates. Round 2 closed the remaining gaps: wired actual K8s Secret resolution at runtime, cascade-deleted orphan refresh records on source delete, surfaced validation warnings in the UI, and hardened the K8s ConfigMap write path with additional tests and improved error messages. Round 3 closed the final production-readiness gaps: wired `SecretResolver` in `cmd/catalog-server/main.go` with namespace defaulting, added plugin-wide refresh status cleanup via `CleanupPluginData`, introduced `RetryOnConflict` for K8s ConfigMap version conflicts with exponential backoff, and added a comprehensive E2E integration test proving the full SecretRef resolution flow.

## Motivation

### Round 1
- **Review finding 1 (K8s persistence)**: Spec was ambiguous about per-source vs single ConfigMap. Implementation already used single ConfigMap correctly; docs needed to match.
- **Review finding 2 (Refresh persistence)**: `lastRefreshTime`, `lastRefreshStatus`, and `lastRefreshSummary` were ephemeral (in-memory only), lost on server restart. Reviewer required DB persistence.
- **Review finding 3 (Secrets)**: Source properties could contain inline credentials (API keys, tokens, passwords) with no redaction or warnings. Reviewer required SecretRef references and redaction on Get.
- **Review finding 4 (Validation)**: `StrictFieldsLayer` validated the source envelope but explicitly skipped `properties.content`. Unknown fields in plugin-specific content were silently ignored. Reviewer required strict validation for both envelope and plugin content.

### Round 2
- **SecretRef resolution not wired**: Type, redaction, and warnings existed but actual K8s Secret reading was not implemented — providers with real secret-backed credentials couldn't function.
- **Orphan refresh status records**: Deleting a source left orphaned rows in `catalog_refresh_status` with no cleanup.
- **Warnings not visible in UI**: `ValidationResultPanel` only displayed errors; warnings from `SecurityWarningsLayer` were invisible to users.
- **K8s write path confidence**: The ConfigMap store needed additional edge-case tests and clearer error messages for version conflicts.

### Round 3
- **SecretResolver wiring not proven**: `K8sSecretResolver` existed as a type but was never instantiated or passed to the server in `cmd/catalog-server/main.go`. No code path created a real resolver at startup.
- **Namespace defaulting unclear**: When a `SecretRef` omitted the `namespace` field, the behavior was undocumented. It needed to default to the server's own K8s namespace (set via `CATALOG_CONFIG_NAMESPACE`).
- **Refresh delete coverage only at source level**: `deleteRefreshStatus` cleaned up individual source records, but no mechanism existed to clean up all records when an entire plugin was removed.
- **Conflict retry strategy missing**: `Save()` on the K8s ConfigMap store returned `ErrVersionConflict` but callers had no retry helper. Concurrent writers could fail permanently on a single conflict.
- **No E2E test proving SecretRef during provider execution**: Unit tests covered individual components (resolver, redaction, `IsSecretRef`) but no test exercised the full flow: SecretRef in source config → resolve → pass to provider → provider receives resolved value → original config not mutated → redaction works on resolved output.

## What Changed

### Files Created

| File | Purpose |
|------|---------|
| `pkg/catalog/plugin/refresh_status.go` | GORM model `RefreshStatusRecord`, save/get/list/delete helpers for DB persistence of refresh metadata |
| `pkg/catalog/plugin/refresh_status_test.go` | 19 tests: save/get round-trip, upsert, list, delete, delete-all, nil-DB safety, handler integration, restart survival |
| `pkg/catalog/plugin/redact.go` | `RedactSensitiveProperties()` and `IsSensitiveKey()` for credential redaction |
| `pkg/catalog/plugin/redact_test.go` | 8 tests: redaction patterns, SecretRef pass-through, case-insensitive matching |
| `pkg/catalog/plugin/secret_resolver.go` | `SecretResolver` interface, `K8sSecretResolver` (reads K8s Secrets), `IsSecretRef()` detector, `ResolveSecretRefs()` property walker |
| `pkg/catalog/plugin/secret_resolver_test.go` | 18+ tests: K8s resolver with fake clientset, missing secret/key errors, `IsSecretRef` edge cases, `ResolveSecretRefs` with nil resolver, mutation safety, error propagation |
| `catalog/plugins/mcp/management_test.go` | 11 tests for strict MCP content validation (unknown fields, valid entries, edge cases) |

### Files Modified (Round 3)

| File | Change |
|------|--------|
| `cmd/catalog-server/main.go` | Wired `NewK8sSecretResolver(clientset, k8sNamespace)` with `WithSecretResolver()` in K8s config store mode; resolver defaults namespace to `CATALOG_CONFIG_NAMESPACE` |
| `pkg/catalog/plugin/secret_resolver.go` | `K8sSecretResolver` uses `defaultNamespace` field; `Resolve()` falls back to `defaultNamespace` when `ref.Namespace` is empty |
| `pkg/catalog/plugin/secret_resolver_test.go` | Added `TestSecretRefResolution_E2E_FullFlow` (full lifecycle: multi-namespace SecretRef resolution, non-mutation, redaction of resolved output, provider callback simulation) |
| `pkg/catalog/plugin/management_handlers_test.go` | Added `TestApplyHandler_ResolvesSecretRefs` (handler flow: server with SecretResolver, apply with SecretRef, plugin receives resolved value, stored config retains original refs) and `TestApplyHandler_SecretRefResolutionFailure` (missing secret returns 500, plugin never called) |
| `pkg/catalog/plugin/server.go` | Added `CleanupPluginData(pluginName)` method that calls `deleteAllRefreshStatuses()` for plugin-wide cleanup |
| `pkg/catalog/plugin/refresh_status.go` | Added `deleteAllRefreshStatuses(pluginName)` helper for plugin-level bulk delete |
| `pkg/catalog/plugin/refresh_status_test.go` | Added `TestCleanupPluginData` (verifies only target plugin's records deleted, other plugins' records preserved) and `TestCleanupPluginData_NilDB` (no panic without DB) |
| `pkg/catalog/plugin/k8s_config_store.go` | Added `RetryOnConflict()` method with exponential backoff (50ms base, doubles per attempt), context cancellation support, and documented `Save()` directing callers to use it |
| `pkg/catalog/plugin/k8s_config_store_test.go` | Added 6 retry tests: `TestRetryOnConflict_SucceedsFirstAttempt`, `_SucceedsAfterRetry`, `_ExhaustsRetries`, `_NonConflictErrorNotRetried`, `_MutateFails`, `_ContextCancelled` |

### Files Modified (Rounds 1-2)

| File | Change |
|------|--------|
| `pkg/catalog/plugin/management_types.go` | Added `SecretRef` struct (Name, Namespace, Key) |
| `pkg/catalog/plugin/management_handlers.go` | Call `saveRefreshStatus` after refresh/apply+refresh; call `deleteRefreshStatus` in deleteSourceHandler; call `RedactSensitiveProperties` in sourcesListHandler; call `ResolveSecretRefs` before plugin operations in applyHandler; enriched SourceStatus from DB in list responses |
| `pkg/catalog/plugin/server.go` | Added `AutoMigrate(&RefreshStatusRecord{})` in Init(); added `secretResolver SecretResolver` field with `WithSecretResolver()` option and `GetSecretResolver()` accessor |
| `pkg/catalog/plugin/validator.go` | Added `WarningOnly` field to `ValidationLayer`; `Validate()` routes warning-only issues to `Warnings`; added `SecurityWarningsLayer()`; wired into `NewDefaultValidator` |
| `pkg/catalog/plugin/validator_test.go` | Updated layer count expectations; added `TestSecurityWarningsLayer` (6 subtests), `TestWarningOnlyLayer` (2 subtests), `TestProviderLayer/provider_catches_unknown_fields_in_content` |
| `pkg/catalog/plugin/k8s_config_store.go` | Improved version conflict error message to include first 8 chars of expected and current version hashes |
| `pkg/catalog/plugin/k8s_config_store_test.go` | Added 7 new tests: save-conflict-includes-versions, rollback-creates-revision, rollback-invalid-data, rollback/load/list-when-configmap-missing, revision-pruning-annotations-cleanup |
| `catalog/plugins/mcp/management.go` | Added `mcpServerStrictEntry`/`mcpServerStrictCatalog` structs; added `validateMcpContent()` with `KnownFields(true)`; called from `ValidateSource()` |
| `deploy/catalog-server/rbac.yaml` | Updated namespace to `catalog-system`; added `secrets` read access (`get` verb) for SecretRef resolution |
| `clients/ui/frontend/.../ValidationResultPanel.tsx` | Auto-expand on warnings; toggle text shows "Validation passed with N warning(s)"; per-layer orange "Warnings" label and yellow alert variant for warning-only layers |
| `clients/ui/bff/internal/mocks/model_catalog_client_mock.go` | Updated `ValidatePluginSource` mock to return `security_warnings` layer with sample warning |
| `catalog_of_catalogs/phase-4-*/00_overview.md` | Added "Review Clarifications (Design Decisions)" section |
| `catalog_of_catalogs/phase-4-*/01_persistence_and_writable_mounts.md` | Confirmed single-ConfigMap design; added SecretRef/redaction subsection |
| `catalog_of_catalogs/phase-4-*/02_yaml_validation_safety_and_rollback.md` | Documented two-level unknown field validation; added acceptance criteria |
| `catalog_of_catalogs/phase-4-*/03_apply_refresh_feedback_loop.md` | Documented DB persistence with full table schema |
| `catalog_of_catalogs/phase-4-*/05_verification_plan_and_acceptance_matrix.md` | Added review-specific test cases and acceptance checks |
| `catalog_of_catalogs/phase-4-*/06_claude_code_execution_guide.md` | Updated checklists with review clarifications |

## How It Works

### Refresh Status Persistence

```go
// RefreshStatusRecord is persisted to catalog_refresh_status table.
type RefreshStatusRecord struct {
    SourceID           string     `gorm:"primaryKey;column:source_id"`
    PluginName         string     `gorm:"column:plugin_name;index"`
    LastRefreshTime    *time.Time `gorm:"column:last_refresh_time"`
    LastRefreshStatus  string     `gorm:"column:last_refresh_status"`  // "success" | "error"
    LastRefreshSummary string     `gorm:"column:last_refresh_summary"`
    LastError          string     `gorm:"column:last_error"`
    EntitiesLoaded     int        `gorm:"column:entities_loaded"`
    EntitiesRemoved    int        `gorm:"column:entities_removed"`
    DurationMs         int64      `gorm:"column:duration_ms"`
    UpdatedAt          time.Time  `gorm:"column:updated_at;autoUpdateTime"`
}
```

After every refresh (manual or apply+refresh), `saveRefreshStatus()` upserts a record. `ListSources()` enriches each `SourceInfo.Status` from the DB, so refresh metadata survives restarts. When a source is deleted, `deleteRefreshStatus()` cascade-deletes the corresponding record. `deleteAllRefreshStatuses()` cleans up all records for a plugin.

### SecretRef Resolution

```go
// SecretResolver resolves SecretRef values to their actual secret data.
type SecretResolver interface {
    Resolve(ctx context.Context, ref SecretRef) (string, error)
}
```

`K8sSecretResolver` uses `kubernetes.Interface` to read `corev1.Secret` objects and extract the referenced data key. `IsSecretRef(v any)` detects map values with string `"name"` and `"key"` fields. `ResolveSecretRefs()` walks a properties map, finds SecretRef-shaped values, resolves them via the resolver, and returns a copy with actual values injected (original properties are never mutated).

In `applyHandler`, SecretRefs are resolved before passing input to the plugin's `ApplySource()`, but the original input (with SecretRefs intact) is persisted to the ConfigStore. This ensures secrets are never written to config storage in plaintext.

The server accepts a `SecretResolver` via `WithSecretResolver()` option, initialized at startup based on deployment mode (K8s mode gets `K8sSecretResolver`, file mode gets nil/no-op).

### SecretRef Redaction

```go
// SecretRef references a value stored in a Kubernetes Secret.
type SecretRef struct {
    Name      string `json:"name" yaml:"name"`
    Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
    Key       string `json:"key" yaml:"key"`
}
```

`RedactSensitiveProperties()` scans property keys for patterns (`password`, `token`, `secret`, `apikey`, `api_key`, `credential`) case-insensitively. Plain string values matching these patterns are replaced with `"***REDACTED***"`. Map values (SecretRef-like objects) are left intact — they don't contain the actual secret, just a reference.

The `SecurityWarningsLayer` uses the same detection but produces warnings (not errors) during validation, advising use of SecretRef instead of inline credentials. The `WarningOnly` flag on `ValidationLayer` ensures warnings populate `DetailedValidationResult.Warnings` without affecting `Valid`.

### Strict Plugin Content Validation

```go
// mcpServerStrictEntry has yaml tags for all 19 known MCP server fields.
type mcpServerStrictEntry struct {
    Name                string `yaml:"name"`
    ExternalID          string `yaml:"externalId"`
    Description         string `yaml:"description"`
    ServerUrl           string `yaml:"serverUrl"`
    // ... 15 more fields
}
```

`validateMcpContent()` in the MCP plugin creates a `yaml.Decoder` with `KnownFields(true)` and decodes `properties.content` against `mcpServerStrictCatalog`. Unknown fields (e.g., `unknownField: true`) produce a `ValidationError` surfaced through the ProviderLayer.

### UI Validation Warnings

The `ValidationResultPanel` component now:
- Auto-expands when validation passes but warnings exist
- Shows "Validation passed with N warning(s)" in the toggle text
- Renders per-layer results with three states: green "Passed", orange "Warnings" (for warning-only layers with issues), and red "Failed"
- Uses `variant="warning"` (yellow) alerts for warning-layer issues vs `variant="danger"` (red) for errors

### K8s ConfigMap Write Path

Version conflict errors now include the first 8 characters of both expected and current version hashes for easier debugging. Seven additional edge-case tests cover: conflict error message content, rollback creating revision entries, handling corrupt revision data, missing ConfigMap scenarios for rollback/load/list-revisions, and verification that pruned revision annotations are actually deleted from the ConfigMap.

RBAC manifests grant `get` access to Secrets (needed for SecretRef resolution) in addition to full ConfigMap CRUD.

### SecretResolver Wiring (Round 3)

In `cmd/catalog-server/main.go`, when the config store mode is `k8s`, the server now creates a real `K8sSecretResolver` and passes it via `WithSecretResolver()`:

```go
secretResolver := plugin.NewK8sSecretResolver(clientset, k8sNamespace)
serverOpts = append(serverOpts, plugin.WithSecretResolver(secretResolver))
```

The `k8sNamespace` value comes from `CATALOG_CONFIG_NAMESPACE` (the same env var used for the ConfigMap store). This means SecretRefs that omit the `namespace` field automatically resolve against the same namespace where the catalog-server's ConfigMap lives.

In file mode and dev mode, no `SecretResolver` is wired — the server's `secretResolver` field remains nil, and `ResolveSecretRefs()` returns properties unchanged (SecretRef maps pass through as-is).

### Namespace Defaulting

```go
func (r *K8sSecretResolver) Resolve(ctx context.Context, ref SecretRef) (string, error) {
    ns := ref.Namespace
    if ns == "" {
        ns = r.defaultNamespace
    }
    secret, err := r.client.CoreV1().Secrets(ns).Get(ctx, ref.Name, metav1.GetOptions{})
    // ...
}
```

The defaulting rule is simple and documented: if `ref.Namespace` is empty, use the resolver's `defaultNamespace` (set at construction from `CATALOG_CONFIG_NAMESPACE`). Source configs can explicitly specify a different namespace for cross-namespace secret access (e.g., `"namespace": "production"` for prod credentials stored in a different namespace).

### Plugin-Wide Cleanup

```go
func (s *Server) CleanupPluginData(pluginName string) {
    s.deleteAllRefreshStatuses(pluginName)
    s.logger.Info("cleaned up plugin data", "plugin", pluginName)
}
```

`CleanupPluginData` is a server-level method that removes all persisted data associated with a plugin. Currently it deletes all refresh status records for the named plugin. This should be called when a plugin is unregistered or permanently removed. The underlying `deleteAllRefreshStatuses` uses `WHERE plugin_name = ?` to scope the delete and is a no-op when the DB is nil.

### RetryOnConflict for K8s ConfigMap

```go
func (s *K8sSourceConfigStore) RetryOnConflict(ctx context.Context,
    mutate func(*CatalogSourcesConfig) error, maxRetries int) (string, error) {
    for attempt := 0; attempt <= maxRetries; attempt++ {
        cfg, version, err := s.Load(ctx)
        if err != nil { return "", fmt.Errorf("load failed: %w", err) }
        if err := mutate(cfg); err != nil { return "", fmt.Errorf("mutate failed: %w", err) }
        newVersion, err := s.Save(ctx, cfg, version)
        if err == nil { return newVersion, nil }
        if !errors.Is(err, ErrVersionConflict) { return "", err }
        select {
        case <-ctx.Done(): return "", ctx.Err()
        case <-time.After(time.Duration(50<<uint(attempt)) * time.Millisecond):
        }
    }
    return "", fmt.Errorf("save failed after %d retries: %w", maxRetries+1, ErrVersionConflict)
}
```

The retry loop uses exponential backoff starting at 50ms, doubling each attempt (50ms, 100ms, 200ms...). It respects context cancellation so callers can bound the total wait time. Non-conflict errors (e.g., network failures, malformed data) are not retried — only `ErrVersionConflict` triggers a retry. The mutate function is re-applied on each attempt against a freshly-loaded config, so it must be idempotent.

### Health Probes

The catalog-server exposes three health endpoints:

- **`/healthz`** and **`/livez`**: Always return 200 with `{"status": "alive", "uptime": "..."}`. These are liveness probes — if the process is running, it's alive.
- **`/readyz`**: Returns 200 only when all components are ready. Checks three components:
  1. **Database**: Calls `sqlDB.Ping()` to verify DB connectivity (or reports `not_configured` if no DB)
  2. **Initial load**: Verifies `initialLoadDone` flag (set after `Init()` completes plugin loading)
  3. **Plugins**: Checks all registered plugins report `Healthy()`, reports degraded count if not

Returns 503 with component breakdown when any component is not ready. The response includes a `components` object with per-component status for debugging.

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| DB table for refresh status, not in-memory | Survives restarts; review explicitly required persistence | In-memory map (fast but ephemeral), ConfigMap annotation (complex, size-limited) |
| Upsert (create-or-update) for refresh records | One record per source avoids unbounded growth | Append-only history table (useful but heavier; revision history covers this) |
| Cascade-delete refresh records on source delete | Prevents orphan rows; simple and predictable | Periodic GC job (complex, delayed cleanup), soft-delete (unnecessary complexity) |
| Warning-only layer type for security checks | Inline credentials are a smell, not a hard error; don't block saves | Hard error (too strict for existing configs), no validation (misses the problem) |
| Redaction in HTTP response path, not storage | Preserves actual values for server-side use; only hides from API consumers | Redact on save (loses data), separate read model (over-engineered) |
| Resolve SecretRefs in handler, persist original refs | Secrets never written to ConfigStore in plaintext; refs remain portable | Resolve on load (leaks to storage), resolve in plugin (duplicates logic) |
| SecretResolver as optional server option | Non-K8s deployments (file mode, dev mode) work without a K8s client | Required dependency (breaks dev mode), env-var fallback (different abstraction) |
| Strict content validation in plugin, not framework | Content schema is plugin-specific; framework can't know valid fields | Generic schema registry (premature abstraction) |
| Pure-Go SQLite (`glebarez/sqlite`) for tests | No CGO dependency; works on all platforms including Windows CI | `mattn/go-sqlite3` (requires CGO), PostgreSQL testcontainers (slow) |
| Version hashes in conflict error messages | Actionable debugging info; helps identify stale-read scenarios | Generic "conflict" message (unhelpful), full version string (too verbose) |
| Wire SecretResolver only in K8s mode | File/dev mode doesn't have K8s Secrets; nil resolver is safe (properties pass through) | Always require resolver (breaks dev mode), mock resolver for dev (unnecessary complexity) |
| Default namespace from CATALOG_CONFIG_NAMESPACE | Same namespace as ConfigMap is the natural scope; explicit cross-namespace refs still work | No defaulting (forces verbose configs), hard-coded default (inflexible) |
| RetryOnConflict with exponential backoff | Concurrent writers resolve naturally; exponential backoff avoids thundering herd | No retry (fragile under contention), fixed delay (wasteful), infinite retry (unbounded) |
| Plugin-wide CleanupPluginData | Single entry point for all cleanup when a plugin is removed; extensible for future cleanup steps | Per-table cleanup methods (scattered, easy to forget), no cleanup (leaks data) |
| E2E test with multi-namespace SecretRefs | Proves the full flow end-to-end including namespace defaulting, non-mutation, and redaction interplay | Separate unit tests only (miss integration issues), live cluster test (slow, fragile) |

## Testing

```bash
# All plugin package tests (includes refresh status, redaction, security warnings, secret resolver, K8s store)
go test ./pkg/catalog/plugin/... -v -count=1

# MCP plugin tests (includes strict content validation)
go test ./catalog/plugins/mcp/... -v -count=1

# Refresh status tests only (includes delete/cleanup)
go test ./pkg/catalog/plugin/... -v -run "TestRefreshStatus|TestSaveRefresh|TestDelete.*Refresh|TestSourcesList.*Enriched" -count=1

# Secret resolver tests only
go test ./pkg/catalog/plugin/... -v -run "TestK8sSecretResolver|TestIsSecretRef|TestResolveSecretRefs" -count=1

# Redaction tests only
go test ./pkg/catalog/plugin/... -v -run "TestRedact|TestIsSensitive" -count=1

# Security warnings tests only
go test ./pkg/catalog/plugin/... -v -run "TestSecurityWarnings|TestWarningOnly" -count=1

# K8s ConfigMap store tests only
go test ./pkg/catalog/plugin/... -v -run "TestK8s" -count=1

# Strict MCP content validation tests only
go test ./catalog/plugins/mcp/... -v -run "TestValidateSource" -count=1

# E2E SecretRef full flow test (resolution + non-mutation + redaction + provider callback)
go test ./pkg/catalog/plugin/... -v -run "TestSecretRefResolution_E2E" -count=1

# Handler-level SecretRef integration tests (apply with resolver, failure on missing secret)
go test ./pkg/catalog/plugin/... -v -run "TestApplyHandler_ResolvesSecretRefs|TestApplyHandler_SecretRefResolutionFailure" -count=1

# Plugin-wide cleanup tests
go test ./pkg/catalog/plugin/... -v -run "TestCleanupPluginData" -count=1

# RetryOnConflict tests (all 6 scenarios)
go test ./pkg/catalog/plugin/... -v -run "TestRetryOnConflict" -count=1
```

## Verification

```bash
# 1. Verify all packages compile
go build ./pkg/catalog/plugin/... ./catalog/plugins/mcp/...

# 2. Run all tests
go test ./pkg/catalog/plugin/... ./catalog/plugins/mcp/... -count=1
# Expected: all ok

# 3. Verify strict validation catches unknown fields (requires running catalog-server)
curl -s -X POST http://localhost:8080/api/mcp_catalog/v1alpha1/sources/mcp-default:validate \
  -H 'Content-Type: application/json' -H 'X-User-Role: operator' \
  -d '{"id":"mcp-default","name":"Test","type":"yaml","properties":{"content":"mcpservers:\n- name: test\n  unknownField: true\n"}}' | python -m json.tool
# Expected: valid: false, error mentioning "unknownField"

# 4. Verify redaction (requires running BFF + catalog-server)
# Add a source with a sensitive property, then GET it — value should be redacted.

# 5. Verify refresh persistence
curl -s -X POST http://localhost:8080/api/mcp_catalog/v1alpha1/refresh/mcp-default \
  -H 'X-User-Role: operator' | python -m json.tool
# Then restart catalog-server and GET /sources — lastRefreshTime should persist.

# 6. Verify refresh cleanup on delete
# Create a source, refresh it, verify refresh status exists, delete source, verify status is gone.

# 7. Verify UI warnings (requires running frontend + BFF)
# Navigate to manage source page, click Validate
# Panel should show "Validation passed with N warning(s)" if sensitive properties exist
# Warning-only layers show orange "Warnings" label with yellow alerts

# 8. Verify K8s store conflict message (via unit test)
go test ./pkg/catalog/plugin/... -v -run "TestK8sConfigStore_Save_VersionConflictIncludesVersions" -count=1
# Expected: error message contains version hash prefixes

# 9. Verify SecretResolver wiring (requires K8s mode catalog-server)
# Start catalog-server with CATALOG_CONFIG_STORE_MODE=k8s
# Create a K8s Secret: kubectl create secret generic test-creds --from-literal=api-key=sk-test123 -n catalog-system
# Apply a source with SecretRef property:
curl -s -X POST http://localhost:8080/api/mcp_catalog/v1alpha1/apply-source \
  -H 'Content-Type: application/json' -H 'X-User-Role: operator' \
  -d '{"id":"test","name":"Test","type":"yaml","properties":{"apiKey":{"name":"test-creds","key":"api-key"}}}'
# Expected: apply succeeds, plugin receives resolved value "sk-test123"

# 10. Verify RetryOnConflict (via unit tests)
go test ./pkg/catalog/plugin/... -v -run "TestRetryOnConflict" -count=1
# Expected: all 6 retry scenarios pass

# 11. Verify plugin-wide cleanup
go test ./pkg/catalog/plugin/... -v -run "TestCleanupPluginData" -count=1
# Expected: only target plugin's records removed

# 12. Verify E2E SecretRef full flow
go test ./pkg/catalog/plugin/... -v -run "TestSecretRefResolution_E2E_FullFlow" -count=1
# Expected: multi-namespace resolution, non-mutation, redaction, provider callback all pass

# 13. Verify health probes (requires running catalog-server)
curl -s http://localhost:8080/livez | python -m json.tool
# Expected: {"status": "alive", "uptime": "..."}
curl -s http://localhost:8080/healthz | python -m json.tool
# Expected: same as /livez
curl -s http://localhost:8080/readyz | python -m json.tool
# Expected: {"status": "ready", "components": {"database": ..., "initial_load": ..., "plugins": ...}}
```

## Dependencies & Impact

- **Depends on**: M4.1 (ConfigStore), M4.2 (validation engine, ProviderLayer), M4.3 (refresh endpoints)
- **Enables**: Production-safe credential handling with real K8s Secret resolution; durable refresh metadata with lifecycle cleanup at both source and plugin level; strict schema enforcement for plugin content; user-visible validation warnings; debuggable K8s write conflicts with automatic retry; health probe readiness for K8s deployment
- **Backward compatibility**: All changes are additive. Existing configs without sensitive fields or unknown content fields are unaffected. The SecurityWarningsLayer produces warnings only (does not break existing saves). Sources without SecretRefs behave identically to before. File-mode deployments work without a SecretResolver (nil is safe). The RetryOnConflict method is opt-in — direct Save() calls still work as before.

## Open Items

- ~~SecretRef resolution requires the server to be started with `WithSecretResolver()` and a K8s client. The wiring in `cmd/catalog-server/main.go` for K8s mode should be verified in a real cluster deployment.~~ **Resolved in Round 3**: `NewK8sSecretResolver` is now wired in `main.go` for K8s mode, with namespace defaulting from `CATALOG_CONFIG_NAMESPACE`.
- The `WarningOnly` mechanism could be extended to additional validation layers beyond security (e.g., deprecation warnings for renamed fields).
- Per-layer warning counts could be added to the UI sidebar summary for quick triage without expanding the validation panel.
- `RetryOnConflict` is available but not yet called from management handlers. When handlers are updated to use the K8s ConfigMap store for concurrent writes, they should adopt `RetryOnConflict` instead of single `Save()` calls.
- `CleanupPluginData` is defined but not yet called from any plugin lifecycle hook. It should be wired into plugin unregistration or shutdown flows when that capability is added.
- Live cluster verification of the full SecretRef → K8s Secret → provider flow has not been performed. The E2E test uses a fake K8s clientset, which is sufficient for correctness but not for validating RBAC, network policies, or secret rotation in a real cluster.
