# M4.4: Health Checks, Readiness, and Probes

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 4 - Catalog Management Productionization

## Summary

Enhanced the catalog-server health endpoints to provide production-grade observability. `/livez` is a lightweight liveness check that always returns 200 with uptime. `/readyz` performs deep readiness checks across three components (database, initial load, plugins) and returns 503 with a component breakdown when any component is unhealthy. Created a minimal healthcheck binary for distroless Docker images and added Kubernetes deployment manifests with startup, liveness, and readiness probes.

## Motivation

- Phase 3's `/healthz` always returned 200 regardless of DB connectivity or initialization state -- it couldn't detect a catalog-server that was running but not actually serving traffic.
- There was no `/livez` endpoint, which is the Kubernetes convention for liveness probes.
- The Docker Compose healthcheck used `wget` which is not available in distroless images.
- No Kubernetes deployment manifests existed for the catalog-server.

## What Changed

### Files Created

| File | Purpose |
|------|---------|
| `cmd/healthcheck/main.go` | Minimal HTTP GET healthcheck binary for distroless images |
| `deploy/catalog-server/deployment.yaml` | K8s Deployment with startup/liveness/readiness probes |
| `deploy/catalog-server/rbac.yaml` | ServiceAccount + Role + RoleBinding for ConfigMap access |

### Files Modified

| File | Change |
|------|--------|
| `pkg/catalog/plugin/server.go` | Added `startedAt`, `initialLoadDone` to Server; enhanced `healthHandler`; rewrote `readyHandler` with component checks; added `/livez` alias |
| `pkg/catalog/plugin/server_test.go` | Added `TestServerHealthzLivezAlias`, updated ready endpoint tests for component structure |
| `Dockerfile.catalog-server` | Added healthcheck binary build and COPY to final image |
| `docker-compose.catalog.yaml` | Updated healthcheck to use `/usr/local/bin/healthcheck http://localhost:8080/readyz` |

## How It Works

### Liveness Endpoint (`/livez`, `/healthz`)

Always returns 200 if the process is alive. No dependency checks -- this is purely for "is the process running" detection:

```json
{"status": "alive", "uptime": "2m30s"}
```

`/healthz` is aliased to the same handler for backward compatibility.

### Readiness Endpoint (`/readyz`)

Checks three components and returns 200 only when all are healthy, 503 otherwise:

```go
func (s *Server) readyHandler(w http.ResponseWriter, r *http.Request) {
    // 1. Database: s.db.DB() + sqlDB.Ping()
    // 2. Initial load: s.initialLoadDone (set at end of Init())
    // 3. Plugins: count healthy vs total

    // Returns component breakdown:
    // {"status": "ready", "components": {
    //   "database": {"status": "up"},
    //   "initial_load": {"status": "complete"},
    //   "plugins": {"status": "healthy", "details": "all 2 plugins healthy"}
    // }}
}
```

When unhealthy:
```json
{
  "status": "not_ready",
  "components": {
    "database": {"status": "down", "error": "connection refused"},
    "initial_load": {"status": "complete"},
    "plugins": {"status": "degraded", "details": "1 of 2 plugins healthy"}
  }
}
```

### Healthcheck Binary

A minimal Go binary that performs an HTTP GET and exits 0 on 2xx, 1 otherwise:

```go
func main() {
    url := os.Args[1]
    resp, err := http.Get(url)
    if err != nil || resp.StatusCode < 200 || resp.StatusCode >= 300 {
        os.Exit(1)
    }
    os.Exit(0)
}
```

### Kubernetes Probes

```yaml
startupProbe:
  httpGet: { path: /readyz, port: 8080 }
  failureThreshold: 30
  periodSeconds: 2        # up to 60s for initial startup
livenessProbe:
  httpGet: { path: /livez, port: 8080 }
  periodSeconds: 10
readinessProbe:
  httpGet: { path: /readyz, port: 8080 }
  periodSeconds: 10
```

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| /livez has no dependency checks | Liveness probes should only detect process death, not transient issues (prevents unnecessary restarts) | Include DB check in liveness (risks restart loops on DB blips) |
| DB check via `sqlDB.Ping()` | Standard Go database health check, works across MySQL/PostgreSQL | Custom query like `SELECT 1` (unnecessary for health check) |
| Separate healthcheck binary | Works in distroless images without shell; tiny binary (~2MB) | Shell-based `wget` or `curl` (unavailable in distroless) |
| Component breakdown in /readyz | Operators can quickly identify which component is unhealthy | Boolean ready/not-ready (insufficient for debugging) |

## Testing

Tests in `server_test.go`:
- `TestServerHealthEndpoint` - Verifies 200 with "alive" status and uptime
- `TestServerHealthzLivezAlias` - Verifies /healthz returns same response as /livez
- `TestServerReadyEndpoint` - Verifies 200 with component breakdown when all healthy
- `TestServerReadyEndpointWithFailedPlugin` - Verifies 503 and "degraded" plugins status

```bash
go test ./pkg/catalog/plugin/... -v -run "TestServerHealth|TestServerReady" -count=1
```

## Verification

```bash
# With Docker stack running:
# Liveness check
curl -s http://localhost:8080/livez | jq

# Readiness check with component breakdown
curl -s http://localhost:8080/readyz | jq '.components'

# Healthz alias
curl -s http://localhost:8080/healthz | jq '.status'

# Verify healthcheck binary in Docker
docker exec catalog-server /usr/local/bin/healthcheck http://localhost:8080/readyz; echo $?
```

## Dependencies & Impact

- **Enables**: Kubernetes deployment with proper probe configuration; Docker Compose with HTTP-based healthcheck
- **Depends on**: Server struct (Phase 3)
- **Backward compatible**: `/healthz` continues to return 200 (now with "alive" status instead of "ok", and includes uptime)

## Open Items

- DB connectivity check uses `Ping()` which only verifies the connection, not query capability. A `SELECT 1` would be more thorough but is likely unnecessary.
- The healthcheck binary could be replaced by `grpc_health_probe` if gRPC support is added in the future.
