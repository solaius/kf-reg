# M4.1: Persistence Hardening

**Date**: 2026-02-16
**Status**: Complete
**Phase**: Phase 4 - Catalog Management Productionization

## Summary

Extended the ConfigStore interface with revision history and rollback capabilities. Implemented two production-ready ConfigStore backends: FileConfigStore (enhanced with `.history/` snapshots, path traversal protection, and size limits) and K8sSourceConfigStore (backed by Kubernetes ConfigMap with annotation-based revision tracking). Added runtime store selection via `CATALOG_CONFIG_STORE_MODE` environment variable.

## Motivation

- Phase 3 introduced `ConfigStore` with Load/Save/Watch, but there was no way to view config change history or revert to a previous version after a bad edit.
- File-based persistence had no security hardening against path traversal or oversized payloads.
- Running in Kubernetes clusters required ConfigMap-backed persistence since file writes don't survive pod restarts.
- Docker Compose mounts were read-only for data, preventing YAML write-back.

## What Changed

### Files Created

| File | Purpose |
|------|---------|
| `pkg/catalog/plugin/k8s_config_store.go` | Kubernetes ConfigMap-backed ConfigStore implementation |
| `pkg/catalog/plugin/k8s_config_store_test.go` | Unit tests using fake K8s clientset |
| `deploy/catalog-server/rbac.yaml` | ServiceAccount + Role + RoleBinding for ConfigMap access |

### Files Modified

| File | Change |
|------|--------|
| `pkg/catalog/plugin/configstore.go` | Added `ConfigRevision` type, `ListRevisions()` and `Rollback()` to interface |
| `pkg/catalog/plugin/file_config_store.go` | Added revision snapshots, path traversal validation, 1 MiB size limit, history pruning |
| `pkg/catalog/plugin/file_config_store_test.go` | Added tests for revisions, rollback, path traversal, oversized files, pruning |
| `cmd/catalog-server/main.go` | Added `CATALOG_CONFIG_STORE_MODE` env var support (file/k8s/none) |
| `docker-compose.catalog.yaml` | Changed MCP data mount from `:ro` to `:rw`, updated healthcheck |

## How It Works

### ConfigStore Interface Extension

Two new methods were added to the existing `ConfigStore` interface:

```go
type ConfigRevision struct {
    Version   string    `json:"version"`
    Timestamp time.Time `json:"timestamp"`
    Size      int64     `json:"size"`
}

type ConfigStore interface {
    Load(ctx context.Context) (*CatalogSourcesConfig, string, error)
    Save(ctx context.Context, cfg *CatalogSourcesConfig, version string) (string, error)
    Watch(ctx context.Context) (<-chan ConfigChangeEvent, error)
    ListRevisions(ctx context.Context) ([]ConfigRevision, error)
    Rollback(ctx context.Context, version string) (*CatalogSourcesConfig, string, error)
}
```

### FileConfigStore Enhancements

Before each atomic write in `Save()`, the current file is snapshotted to `.history/{unix_timestamp}_{version_short}.yaml`. The history is pruned to keep only the most recent 20 revisions.

```go
func (s *FileConfigStore) snapshotCurrent(data []byte, version string) error {
    histDir := s.historyDir()
    os.MkdirAll(histDir, 0o755)
    versionShort := version[:min(len(version), 8)]
    filename := fmt.Sprintf("%d_%s.yaml", time.Now().Unix(), versionShort)
    return os.WriteFile(filepath.Join(histDir, filename), data, 0o644)
}
```

Security hardening:
- Path traversal: `NewFileConfigStore()` validates that the cleaned path has no `..` segments
- Size limit: Both `Load()` and `Save()` enforce a 1 MiB maximum (`maxConfigFileSize = 1 << 20`)

### K8sSourceConfigStore

Stores config YAML in a ConfigMap data key, with revision metadata in annotations:

- `catalog.kubeflow.org/revisions`: JSON array of `ConfigRevision` entries
- `catalog.kubeflow.org/rev-{version}`: Data snapshot for each revision (max 10 kept)

Optimistic concurrency uses SHA-256 content hashing (not K8s resourceVersion) for consistency with the FileConfigStore API contract.

### Config Store Mode Selection

```go
switch configStoreStr {
case "file":   // FileConfigStore (default)
case "k8s":    // K8sSourceConfigStore with in-cluster config
case "none":   // No persistence, mutations stay in-memory
}
```

K8s mode reads from environment: `CATALOG_CONFIG_NAMESPACE`, `CATALOG_CONFIG_CONFIGMAP_NAME`, `CATALOG_CONFIG_CONFIGMAP_KEY`.

## Key Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Content hash for concurrency (not K8s resourceVersion) | Consistent API across both store backends | resourceVersion would only work for K8s store |
| Revision snapshots in .history/ directory | Simple, inspectable, works without extra deps | SQLite DB, embedded key-value store |
| K8s revision data in annotations | No extra ConfigMaps needed, atomic with config updates | Secondary ConfigMap per revision |
| Max 20 file revisions, 10 K8s revisions | K8s annotations have tighter size limits | Configurable limits (unnecessary complexity) |

## Testing

- `TestFileConfigStore_RevisionCreatedOnSave` - Verifies snapshots are created
- `TestFileConfigStore_ListRevisions` - Verifies listing returns entries sorted newest first
- `TestFileConfigStore_RollbackRestoresPrevious` - Verifies full rollback flow
- `TestFileConfigStore_HistoryPruning` - Verifies pruning to 20 max
- `TestFileConfigStore_PathTraversal` - Verifies rejection of `..` paths
- `TestFileConfigStore_OversizedFile` - Verifies rejection of files > 1 MiB
- `TestK8sConfigStore_*` - 14 tests covering Load, Save, ListRevisions, Rollback with fake clientset

```bash
go test ./pkg/catalog/plugin/... -v -run "TestFileConfigStore|TestK8s" -count=1
```

## Verification

```bash
# Run unit tests
go test ./pkg/catalog/plugin/... -v -count=1

# Verify code compiles
go vet ./pkg/catalog/plugin/... ./cmd/catalog-server/...

# Start Docker stack with rw mount
docker compose -f docker-compose.catalog.yaml up --build -d

# Verify healthcheck binary works
curl -s http://localhost:8080/readyz | jq
```

## Dependencies & Impact

- **Enables**: M4.2 (validation + rollback endpoints rely on ListRevisions/Rollback)
- **Depends on**: Phase 3 ConfigStore interface (Load/Save/Watch)
- **Backward compatible**: Existing code using ConfigStore continues to work; new methods are additive

## Open Items

- K8s Watch() is a stub (returns nil) -- could use informers for push-based reconciliation
- Revision data in K8s annotations is limited by etcd value size; very large configs may not have full snapshot history
